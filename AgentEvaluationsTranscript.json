1
00: 00: 0, 680 --> 00: 00: 4, 279
hi I'm David from Lang chain today I'll 2
00: 00: 2, 830 --> 00: 00: 4, 279 3
00: 00: 2, 840 --> 00: 00: 6, 160
be walking through how you can both 4
00: 00: 4, 269 --> 00: 00: 6, 160 5
00: 00: 4, 279 --> 00: 00: 8, 880
build and evaluate a customer support 6
00: 00: 6, 150 --> 00: 00: 8, 880 7
00: 00: 6, 160 --> 00: 00: 11, 360
agent before filming this video I built 8
00: 00: 8, 870 --> 00: 00: 11, 360 9
00: 00: 8, 880 --> 00: 00: 13, 519
a customer support agent using langra 10
00: 00: 11, 350 --> 00: 00: 13, 519 11
00: 00: 11, 360 --> 00: 00: 16, 119
and ported it over to langra Studio 12
00: 00: 13, 509 --> 00: 00: 16, 119 13
00: 00: 13, 519 --> 00: 00: 17, 880
which is where we are now langra studio 14
00: 00: 16, 109 --> 00: 00: 17, 880 15
00: 00: 16, 119 --> 00: 00: 20, 199
is a specialized I where you can 16
00: 00: 17, 870 --> 00: 00: 20, 199 17
00: 00: 17, 880 --> 00: 00: 22, 840
interact with debug and visualize your 18
00: 00: 20, 189 --> 00: 00: 22, 840 19
00: 00: 20, 199 --> 00: 00: 25, 080
agent the customer support agent I buil 20
00: 00: 22, 830 --> 00: 00: 25, 080 21
00: 00: 22, 840 --> 00: 00: 27, 439
is designed to assist customers of a 22
00: 00: 25, 070 --> 00: 00: 27, 439 23
00: 00: 25, 080 --> 00: 00: 30, 119
digital music store this customer 24
00: 00: 27, 429 --> 00: 00: 30, 119 25
00: 00: 27, 439 --> 00: 00: 32, 399
support agent has access to a SQL 26
00: 00: 30, 109 --> 00: 00: 32, 399 27
00: 00: 30, 119 --> 00: 00: 34, 160
database that not only has information 28
00: 00: 32, 389 --> 00: 00: 34, 160 29
00: 00: 32, 399 --> 00: 00: 36, 840
on the products and the offerings of the 30
00: 00: 34, 150 --> 00: 00: 36, 840 31
00: 00: 34, 160 --> 00: 00: 38, 120
digital music store but also information 32
00: 00: 36, 830 --> 00: 00: 38, 120 33
00: 00: 36, 840 --> 00: 00: 40, 079
on customers who have shopped at the 34
00: 00: 38, 110 --> 00: 00: 40, 079 35
00: 00: 38, 120 --> 00: 00: 41, 000
store in the past and details on their 36
00: 00: 40, 069 --> 00: 00: 41, 000 37
00: 00: 40, 079 --> 00: 00: 43, 079
past 38
00: 00: 40, 990 --> 00: 00: 43, 079 39
00: 00: 41, 000 --> 00: 00: 45, 480
purchases this customer support agent 40
00: 00: 43, 069 --> 00: 00: 45, 480 41
00: 00: 43, 079 --> 00: 00: 47, 360
has two core functionalities the first 42
00: 00: 45, 470 --> 00: 00: 47, 360 43
00: 00: 45, 480 --> 00: 00: 49, 600
is the ability to answer questions about 44
00: 00: 47, 350 --> 00: 00: 49, 600 45
00: 00: 47, 360 --> 00: 00: 51, 360
the products and offerings of the store 46
00: 00: 49, 590 --> 00: 00: 51, 360 47
00: 00: 49, 600 --> 00: 00: 53, 760
this is questions do you have any 48
00: 00: 51, 350 --> 00: 00: 53, 760 49
00: 00: 51, 360 --> 00: 00: 55, 079
songs by Amy win housee do you have any 50
00: 00: 53, 750 --> 00: 00: 55, 079 51
00: 00: 53, 760 --> 00: 00: 57, 359
album by Pink 52
00: 00: 55, 069 --> 00: 00: 57, 359 53
00: 00: 55, 079 --> 00: 01: 0, 239
Floyd the second functionality is the 54
00: 00: 57, 349 --> 00: 01: 0, 239 55
00: 00: 57, 359 --> 00: 01: 2, 440
ability to handle and process customer 56
00: 01: 0, 229 --> 00: 01: 2, 440 57
00: 01: 0, 239 --> 00: 01: 4, 640
refunds each of these functionalities is 58
00: 01: 2, 430 --> 00: 01: 4, 640 59
00: 01: 2, 440 --> 00: 01: 6, 920
handled by a separate subgraph in our 60
00: 01: 4, 630 --> 00: 01: 6, 920 61
00: 01: 4, 640 --> 00: 01: 8, 960
architecture and we can see here we have 62
00: 01: 6, 910 --> 00: 01: 8, 960 63
00: 01: 6, 920 --> 00: 01: 10, 600
this question and answering subgraph 64
00: 01: 8, 950 --> 00: 01: 10, 600 65
00: 01: 8, 960 --> 00: 01: 12, 280
that handles the queries related to the 66
00: 01: 10, 590 --> 00: 01: 12, 280 67
00: 01: 10, 600 --> 00: 01: 15, 119
products and offerings of the music 68
00: 01: 12, 270 --> 00: 01: 15, 119 69
00: 01: 12, 280 --> 00: 01: 17, 400
store we have the refund subgraph that 70
00: 01: 15, 109 --> 00: 01: 17, 400 71
00: 01: 15, 119 --> 00: 01: 19, 880
handles and processes customer refund 72
00: 01: 17, 390 --> 00: 01: 19, 880 73
00: 01: 17, 400 --> 00: 01: 22, 960
requests and we're routed to each of 74
00: 01: 19, 870 --> 00: 01: 22, 960 75
00: 01: 19, 880 --> 00: 01: 25, 920
these subgraphs by our supervisor or 76
00: 01: 22, 950 --> 00: 01: 25, 920 77
00: 01: 22, 960 --> 00: 01: 27, 920
intent classifier node so when a query 78
00: 01: 25, 910 --> 00: 01: 27, 920 79
00: 01: 25, 920 --> 00: 01: 29, 920
comes into our graph the intent 80
00: 01: 27, 910 --> 00: 01: 29, 920 81
00: 01: 27, 920 --> 00: 01: 31, 040
classifier or supervisor node the 82
00: 01: 29, 910 --> 00: 01: 31, 040 83
00: 01: 29, 920 --> 00: 01: 33, 720
determines whether it should be routed 84
00: 01: 31, 030 --> 00: 01: 33, 720 85
00: 01: 31, 040 --> 00: 01: 34, 720
to the refund subgraph or the question 86
00: 01: 33, 710 --> 00: 01: 34, 720 87
00: 01: 33, 720 --> 00: 01: 37, 240
answering 88
00: 01: 34, 710 --> 00: 01: 37, 240 89
00: 01: 34, 720 --> 00: 01: 39, 759
subgraph the last node we have here in 90
00: 01: 37, 230 --> 00: 01: 39, 759 91
00: 01: 37, 240 --> 00: 01: 41, 880
architecture is called compile followup 92
00: 01: 39, 749 --> 00: 01: 41, 880 93
00: 01: 39, 759 --> 00: 01: 44, 600
all it does is clean up the state of our 94
00: 01: 41, 870 --> 00: 01: 44, 600 95
00: 01: 41, 880 --> 00: 01: 45, 520
agent and return a nice final output to 96
00: 01: 44, 590 --> 00: 01: 45, 520 97
00: 01: 44, 600 --> 00: 01: 47, 880
the 98
00: 01: 45, 510 --> 00: 01: 47, 880 99
00: 01: 45, 520 --> 00: 01: 50, 399
user let's ask our agent two 100
00: 01: 47, 870 --> 00: 01: 50, 399 101
00: 01: 47, 880 --> 00: 01: 52, 159
questions and see an action here so 102
00: 01: 50, 389 --> 00: 01: 52, 159 103
00: 01: 50, 399 --> 00: 01: 54, 479
I'm going to go ahead and copy and paste 104
00: 01: 52, 149 --> 00: 01: 54, 479 105
00: 01: 52, 159 --> 00: 01: 56, 520
a predefined message I have here the 106
00: 01: 54, 469 --> 00: 01: 56, 520 107
00: 01: 54, 479 --> 00: 01: 57, 759
message is my name is Mark Phillips 108
00: 01: 56, 510 --> 00: 01: 57, 759 109
00: 01: 56, 520 --> 00: 02: 1, 280
here's my phone number so you can 110
00: 01: 57, 749 --> 00: 02: 1, 280 111
00: 01: 57, 759 --> 00: 02: 3, 960
identify me in the SQL database I want 112
00: 02: 1, 270 --> 00: 02: 3, 960 113
00: 02: 1, 280 --> 00: 02: 6, 920
to refund on a past purchase when we 114
00: 02: 3, 950 --> 00: 02: 6, 920 115
00: 02: 3, 960 --> 00: 02: 9, 560
click submit our intent classifier node 116
00: 02: 6, 910 --> 00: 02: 9, 560 117
00: 02: 6, 920 --> 00: 02: 12, 040
will correctly route it to the refund 118
00: 02: 9, 550 --> 00: 02: 12, 040 119
00: 02: 9, 560 --> 00: 02: 13, 280
agent and if we scroll the way down 120
00: 02: 12, 030 --> 00: 02: 13, 280 121
00: 02: 12, 040 --> 00: 02: 16, 120
we'll see that our customer support 122
00: 02: 13, 270 --> 00: 02: 16, 120 123
00: 02: 13, 280 --> 00: 02: 17, 319
agent correctly responded and said all 124
00: 02: 16, 110 --> 00: 02: 17, 319 125
00: 02: 16, 120 --> 00: 02: 18, 640 Mark which of the following 126
00: 02: 17, 309 --> 00: 02: 18, 640 127
00: 02: 17, 319 --> 00: 02: 22, 000
purchases would you to be refunded 128
00: 02: 18, 630 --> 00: 02: 22, 000 129
00: 02: 18, 640 --> 00: 02: 23, 640
for and we return a list of invoice IDs 130
00: 02: 21, 990 --> 00: 02: 23, 640 131
00: 02: 22, 000 --> 00: 02: 26, 519
in the database that are associated with 132
00: 02: 23, 630 --> 00: 02: 26, 519 133
00: 02: 23, 640 --> 00: 02: 28, 720
his name first name last name 134
00: 02: 26, 509 --> 00: 02: 28, 720 135
00: 02: 26, 519 --> 00: 02: 31, 280
and phone number and now Mark can follow 136
00: 02: 28, 710 --> 00: 02: 31, 280 137
00: 02: 28, 720 --> 00: 02: 33, 280
up with the invoice or IDs that he would 138
00: 02: 31, 270 --> 00: 02: 33, 280 139
00: 02: 31, 280 --> 00: 02: 36, 120 a refund for and walks you to 140
00: 02: 33, 270 --> 00: 02: 36, 120 141
00: 02: 33, 280 --> 00: 02: 37, 200
the SQL database and execute that refund 142
00: 02: 36, 110 --> 00: 02: 37, 200 143
00: 02: 36, 120 --> 00: 02: 39, 360
for 144
00: 02: 37, 190 --> 00: 02: 39, 360 145
00: 02: 37, 200 --> 00: 02: 40, 879
him for the sake of time I'm not going 146
00: 02: 39, 350 --> 00: 02: 40, 879 147
00: 02: 39, 360 --> 00: 02: 42, 879
to ask that followup I'm going 148
00: 02: 40, 869 --> 00: 02: 42, 879 149
00: 02: 40, 879 --> 00: 02: 46, 040
to ask another question that will be 150
00: 02: 42, 869 --> 00: 02: 46, 040 151
00: 02: 42, 879 --> 00: 02: 48, 800
handled by our question answer subgraph 152
00: 02: 46, 030 --> 00: 02: 48, 800 153
00: 02: 46, 040 --> 00: 02: 50, 280
so here I'll say never mind do you have 154
00: 02: 48, 790 --> 00: 02: 50, 280 155
00: 02: 48, 800 --> 00: 02: 54, 879
any 156
00: 02: 50, 270 --> 00: 02: 54, 879 157
00: 02: 50, 280 --> 00: 02: 57, 800
songs for sale by in me Wine 158
00: 02: 54, 869 --> 00: 02: 57, 800 159
00: 02: 54, 879 --> 00: 03: 0, 560
House great now when I hit submit you'll 160
00: 02: 57, 790 --> 00: 03: 0, 560 161
00: 02: 57, 800 --> 00: 03: 3, 360
see that my agent correctly routed the 162
00: 03: 0, 550 --> 00: 03: 3, 360 163
00: 03: 0, 560 --> 00: 03: 7, 040
question over to the question answering 164
00: 03: 3, 350 --> 00: 03: 7, 040 165
00: 03: 3, 360 --> 00: 03: 9, 799
subgraph and when I scroll the way 166
00: 03: 7, 030 --> 00: 03: 9, 799 167
00: 03: 7, 040 --> 00: 03: 11, 680
down we can see that my assistant 168
00: 03: 9, 789 --> 00: 03: 11, 680 169
00: 03: 9, 799 --> 00: 03: 13, 239
returned the following answer yes we 170
00: 03: 11, 670 --> 00: 03: 13, 239 171
00: 03: 11, 680 --> 00: 03: 15, 000
have several Amy wi housee songs 172
00: 03: 13, 229 --> 00: 03: 15, 000 173
00: 03: 13, 239 --> 00: 03: 17, 959
available from our albums Back to Black 174
00: 03: 14, 990 --> 00: 03: 17, 959 175
00: 03: 15, 000 --> 00: 03: 20, 200
and Frank and it returns 12 songs from 176
00: 03: 17, 949 --> 00: 03: 20, 200 177
00: 03: 17, 959 --> 00: 03: 21, 080
the album back to black and 11 from the 178
00: 03: 20, 190 --> 00: 03: 21, 080 179
00: 03: 20, 200 --> 00: 03: 23, 159
album 180
00: 03: 21, 070 --> 00: 03: 23, 159 181
00: 03: 21, 080 --> 00: 03: 25, 640
Frank great so that's a really quick 182
00: 03: 23, 149 --> 00: 03: 25, 640 183
00: 03: 23, 159 --> 00: 03: 27, 920
overview of what our agent looks 184
00: 03: 25, 630 --> 00: 03: 27, 920 185
00: 03: 25, 640 --> 00: 03: 30, 519
and does now let's dive into both 186
00: 03: 27, 910 --> 00: 03: 30, 519 187
00: 03: 27, 920 --> 00: 03: 32, 040
building and evaluating it 188
00: 03: 30, 509 --> 00: 03: 32, 040 189
00: 03: 30, 519 --> 00: 03: 33, 480
before I hop into a notebook and show 190
00: 03: 32, 030 --> 00: 03: 33, 480 191
00: 03: 32, 040 --> 00: 03: 35, 760
off how to evaluate this customer 192
00: 03: 33, 470 --> 00: 03: 35, 760 193
00: 03: 33, 480 --> 00: 03: 37, 959
support agent in code I'm first going to 194
00: 03: 35, 750 --> 00: 03: 37, 959 195
00: 03: 35, 760 --> 00: 03: 40, 080
touch on at a high level why evaluating 196
00: 03: 37, 949 --> 00: 03: 40, 080 197
00: 03: 37, 959 --> 00: 03: 42, 280
an agent is difficult and why it's 198
00: 03: 40, 070 --> 00: 03: 42, 280 199
00: 03: 40, 080 --> 00: 03: 44, 400
important it's difficult to evaluate an 200
00: 03: 42, 270 --> 00: 03: 44, 400 201
00: 03: 42, 280 --> 00: 03: 47, 080
agent because today agents take a large 202
00: 03: 44, 390 --> 00: 03: 47, 080 203
00: 03: 44, 400 --> 00: 03: 48, 879
number of steps before turning an output 204
00: 03: 47, 070 --> 00: 03: 48, 879 205
00: 03: 47, 080 --> 00: 03: 51, 200
and these steps are not explicitly 206
00: 03: 48, 869 --> 00: 03: 51, 200 207
00: 03: 48, 879 --> 00: 03: 52, 760
defined beforehand by a developer 208
00: 03: 51, 190 --> 00: 03: 52, 760 209
00: 03: 51, 200 --> 00: 03: 55, 560
they're instead determined dynamically 210
00: 03: 52, 750 --> 00: 03: 55, 560 211
00: 03: 52, 760 --> 00: 03: 58, 159
by an llm or multiple 212
00: 03: 55, 550 --> 00: 03: 58, 159 213
00: 03: 55, 560 --> 00: 04: 0, 319
LMS as a result when you're evaluating 214
00: 03: 58, 149 --> 00: 04: 0, 319 215
00: 03: 58, 159 --> 00: 04: 3, 159
an agent you not only want to make sure 216
00: 04: 0, 309 --> 00: 04: 3, 159 217
00: 04: 0, 319 --> 00: 04: 5, 079
it's producing a high quality output but 218
00: 04: 3, 149 --> 00: 04: 5, 079 219
00: 04: 3, 159 --> 00: 04: 6, 519
also that the path or the trajectory 220
00: 04: 5, 069 --> 00: 04: 6, 519 221
00: 04: 5, 079 --> 00: 04: 8, 760
that it followed when constructing that 222
00: 04: 6, 509 --> 00: 04: 8, 760 223
00: 04: 6, 519 --> 00: 04: 10, 720
final output is 224
00: 04: 8, 750 --> 00: 04: 10, 720 225
00: 04: 8, 760 --> 00: 04: 13, 920
optimal and we can use our customer 226
00: 04: 10, 710 --> 00: 04: 13, 920 227
00: 04: 10, 720 --> 00: 04: 15, 200
support agent here as an example so if I 228
00: 04: 13, 910 --> 00: 04: 15, 200 229
00: 04: 13, 920 --> 00: 04: 17, 639
were to be evaluating this customer 230
00: 04: 15, 190 --> 00: 04: 17, 639 231
00: 04: 15, 200 --> 00: 04: 20, 280
support agent and it were to receive a 232
00: 04: 17, 629 --> 00: 04: 20, 280 233
00: 04: 17, 639 --> 00: 04: 22, 280
query from a user and let's say the 234
00: 04: 20, 270 --> 00: 04: 22, 280 235
00: 04: 20, 280 --> 00: 04: 24, 720
question is what songs do you have by 236
00: 04: 22, 270 --> 00: 04: 24, 720 237
00: 04: 22, 280 --> 00: 04: 27, 040
Amy win housee I'd want to make sure 238
00: 04: 24, 710 --> 00: 04: 27, 040 239
00: 04: 24, 720 --> 00: 04: 30, 120
that my customer support agent not only 240
00: 04: 27, 030 --> 00: 04: 30, 120 241
00: 04: 27, 040 --> 00: 04: 33, 039
produces a high quality accurate output 242
00: 04: 30, 110 --> 00: 04: 33, 039 243
00: 04: 30, 120 --> 00: 04: 35, 080
but also that it routes the query to the 244
00: 04: 33, 029 --> 00: 04: 35, 080 245
00: 04: 33, 039 --> 00: 04: 37, 479
correct subgraph in this case the 246
00: 04: 35, 070 --> 00: 04: 37, 479 247
00: 04: 35, 080 --> 00: 04: 39, 560
question answering subgraph and within 248
00: 04: 37, 469 --> 00: 04: 39, 560 249
00: 04: 37, 479 --> 00: 04: 41, 680
this subgraph we call the tools 250
00: 04: 39, 550 --> 00: 04: 41, 680 251
00: 04: 39, 560 --> 00: 04: 43, 919
and we call them in the 252
00: 04: 41, 670 --> 00: 04: 43, 919 253
00: 04: 41, 680 --> 00: 04: 45, 800
order now it's important to evaluate 254
00: 04: 43, 909 --> 00: 04: 45, 800 255
00: 04: 43, 919 --> 00: 04: 48, 120
both the final output and the trajectory 256
00: 04: 45, 790 --> 00: 04: 48, 120 257
00: 04: 45, 800 --> 00: 04: 49, 800
or the steps that the agent takes 258
00: 04: 48, 110 --> 00: 04: 49, 800 259
00: 04: 48, 120 --> 00: 04: 52, 199
because you can have a world in which 260
00: 04: 49, 790 --> 00: 04: 52, 199 261
00: 04: 49, 800 --> 00: 04: 55, 160
the output is high quality and the 262
00: 04: 52, 189 --> 00: 04: 55, 160 263
00: 04: 52, 199 --> 00: 04: 57, 400
trajectory was very unoptimal and 264
00: 04: 55, 150 --> 00: 04: 57, 400 265
00: 04: 55, 160 --> 00: 04: 59, 440
inefficient for example you can imagine 266
00: 04: 57, 390 --> 00: 04: 59, 440 267
00: 04: 57, 400 --> 00: 05: 0, 759
a world in which we receive a query 268
00: 04: 59, 430 --> 00: 05: 0, 759 269
00: 04: 59, 440 --> 00: 05: 3, 400
about Amy wiin 270
00: 05: 0, 749 --> 00: 05: 3, 400 271
00: 05: 0, 759 --> 00: 05: 5, 120
houseee our supervisor node or our 272
00: 05: 3, 390 --> 00: 05: 5, 120 273
00: 05: 3, 400 --> 00: 05: 6, 759
intent classification step correctly 274
00: 05: 5, 110 --> 00: 05: 6, 759 275
00: 05: 5, 120 --> 00: 05: 9, 160
routes the question to the question 276
00: 05: 6, 749 --> 00: 05: 9, 160 277
00: 05: 6, 759 --> 00: 05: 12, 320
answering subgraph but within the 278
00: 05: 9, 150 --> 00: 05: 12, 320 279
00: 05: 9, 160 --> 00: 05: 14, 479
question answering subgraph we call one 280
00: 05: 12, 310 --> 00: 05: 14, 479 281
00: 05: 12, 320 --> 00: 05: 16, 560
tool an unnecessary number of times and 282
00: 05: 14, 469 --> 00: 05: 16, 560 283
00: 05: 14, 479 --> 00: 05: 20, 000
we call some incorrect 284
00: 05: 16, 550 --> 00: 05: 20, 000 285
00: 05: 16, 560 --> 00: 05: 22, 319
tools we will still likely return an 286
00: 05: 19, 990 --> 00: 05: 22, 319 287
00: 05: 20, 000 --> 00: 05: 24, 600
output that's accurate in 288
00: 05: 22, 309 --> 00: 05: 24, 600 289
00: 05: 22, 319 --> 00: 05: 25, 919
quality but the inefficiency that took 290
00: 05: 24, 590 --> 00: 05: 25, 919 291
00: 05: 24, 600 --> 00: 05: 28, 479
place within the question answering 292
00: 05: 25, 909 --> 00: 05: 28, 479 293
00: 05: 25, 919 --> 00: 05: 30, 759
subgraph led to a lot of unnecessary 294
00: 05: 28, 469 --> 00: 05: 30, 759 295
00: 05: 28, 479 --> 00: 05: 33, 360
latency and a lot of unnecessary 296
00: 05: 30, 749 --> 00: 05: 33, 360 297
00: 05: 30, 759 --> 00: 05: 35, 759
number of tokens 298
00: 05: 33, 350 --> 00: 05: 35, 759 299
00: 05: 33, 360 --> 00: 05: 37, 520
generated and this is also a really 300
00: 05: 35, 749 --> 00: 05: 37, 520 301
00: 05: 35, 759 --> 00: 05: 39, 759
really good illustration of why 302
00: 05: 37, 510 --> 00: 05: 39, 759 303
00: 05: 37, 520 --> 00: 05: 41, 680
evaluating an agent in general is so 304
00: 05: 39, 749 --> 00: 05: 41, 680 305
00: 05: 39, 759 --> 00: 05: 43, 720
important because let's say you make a 306
00: 05: 41, 670 --> 00: 05: 43, 720 307
00: 05: 41, 680 --> 00: 05: 45, 199
change to your agent it can be a small 308
00: 05: 43, 710 --> 00: 05: 45, 199 309
00: 05: 43, 720 --> 00: 05: 47, 680
change switching to a new model 310
00: 05: 45, 189 --> 00: 05: 47, 680 311
00: 05: 45, 199 --> 00: 05: 49, 919
provider or iterating some prompts in 312
00: 05: 47, 670 --> 00: 05: 49, 919 313
00: 05: 47, 680 --> 00: 05: 52, 240
the application or more substantial 314
00: 05: 49, 909 --> 00: 05: 52, 240 315
00: 05: 49, 919 --> 00: 05: 54, 120
change such as one that fundamentally 316
00: 05: 52, 230 --> 00: 05: 54, 120 317
00: 05: 52, 240 --> 00: 05: 56, 360
changes the Cog of architecture of the 318
00: 05: 54, 110 --> 00: 05: 56, 360 319
00: 05: 54, 120 --> 00: 05: 59, 479
agent you want to make sure that this 320
00: 05: 56, 350 --> 00: 05: 59, 479 321
00: 05: 56, 360 --> 00: 06: 1, 120
change would not degrade some part of 322
00: 05: 59, 469 --> 00: 06: 1, 120 323
00: 05: 59, 479 --> 00: 06: 3, 240
your applications performance 324
00: 06: 1, 110 --> 00: 06: 3, 240 325
00: 06: 1, 120 --> 00: 06: 6, 720
whether that's latency whether that's 326
00: 06: 3, 230 --> 00: 06: 6, 720 327
00: 06: 3, 240 --> 00: 06: 8, 680
tokens or the quality of the final 328
00: 06: 6, 710 --> 00: 06: 8, 680 329
00: 06: 6, 720 --> 00: 06: 11, 199
output and you want to make sure you 330
00: 06: 8, 670 --> 00: 06: 11, 199 331
00: 06: 8, 680 --> 00: 06: 12, 960
catch this potential regression before 332
00: 06: 11, 189 --> 00: 06: 12, 960 333
00: 06: 11, 199 --> 00: 06: 15, 759
you push to change production and make 334
00: 06: 12, 950 --> 00: 06: 15, 759 335
00: 06: 12, 960 --> 00: 06: 17, 960
it live for all your users 336
00: 06: 15, 749 --> 00: 06: 17, 960 337
00: 06: 15, 759 --> 00: 06: 20, 319
great so let's evaluate this 338
00: 06: 17, 950 --> 00: 06: 20, 319 339
00: 06: 17, 960 --> 00: 06: 21, 680
customer support agent and to evaluate 340
00: 06: 20, 309 --> 00: 06: 21, 680 341
00: 06: 20, 319 --> 00: 06: 22, 440
this customer support agent let's use 342
00: 06: 21, 670 --> 00: 06: 22, 440 343
00: 06: 21, 680 --> 00: 06: 24, 759
three 344
00: 06: 22, 430 --> 00: 06: 24, 759 345
00: 06: 22, 440 --> 00: 06: 27, 319
strategies the first strategy is going 346
00: 06: 24, 749 --> 00: 06: 27, 319 347
00: 06: 24, 759 --> 00: 06: 31, 120
to evaluate whether it's producing 348
00: 06: 27, 309 --> 00: 06: 31, 120 349
00: 06: 27, 319 --> 00: 06: 32, 280
quality accurate final outputs 350
00: 06: 31, 110 --> 00: 06: 32, 280 351
00: 06: 31, 120 --> 00: 06: 33, 960
the second strategy we're going to 352
00: 06: 32, 270 --> 00: 06: 33, 960 353
00: 06: 32, 280 --> 00: 06: 36, 360
utilize is going to make sure 354
00: 06: 33, 950 --> 00: 06: 36, 360 355
00: 06: 33, 960 --> 00: 06: 37, 280
that a single step in our agent is 356
00: 06: 36, 350 --> 00: 06: 37, 280 357
00: 06: 36, 360 --> 00: 06: 40, 199
behaving 358
00: 06: 37, 270 --> 00: 06: 40, 199 359
00: 06: 37, 280 --> 00: 06: 42, 000
correctly in this case the evaluation is 360
00: 06: 40, 189 --> 00: 06: 42, 000 361
00: 06: 40, 199 --> 00: 06: 45, 360
going to make sure that our supervisor 362
00: 06: 41, 990 --> 00: 06: 45, 360 363
00: 06: 42, 000 --> 00: 06: 48, 199
node or our intent classification step 364
00: 06: 45, 350 --> 00: 06: 48, 199 365
00: 06: 45, 360 --> 00: 06: 50, 639
is correctly routing to the appropriate 366
00: 06: 48, 189 --> 00: 06: 50, 639 367
00: 06: 48, 199 --> 00: 06: 53, 639
subgraph so for example when the 368
00: 06: 50, 629 --> 00: 06: 53, 639 369
00: 06: 50, 639 --> 00: 06: 55, 599
supervisor node receives a query about a 370
00: 06: 53, 629 --> 00: 06: 55, 599 371
00: 06: 53, 639 --> 00: 06: 57, 240
a customer refund we'd want to make sure 372
00: 06: 55, 589 --> 00: 06: 57, 240 373
00: 06: 55, 599 --> 00: 06: 59, 800
this node correctly routes to the 374
00: 06: 57, 230 --> 00: 06: 59, 800 375
00: 06: 57, 240 --> 00: 07: 1, 800
process refund subgraph and if it to 376
00: 06: 59, 790 --> 00: 07: 1, 800 377
00: 06: 59, 800 --> 00: 07: 3, 919
receive a question about the products or 378
00: 07: 1, 790 --> 00: 07: 3, 919 379
00: 07: 1, 800 --> 00: 07: 5, 919
the offerings of the music store we want 380
00: 07: 3, 909 --> 00: 07: 5, 919 381
00: 07: 3, 919 --> 00: 07: 8, 000
to make sure this intent classification 382
00: 07: 5, 909 --> 00: 07: 8, 000 383
00: 07: 5, 919 --> 00: 07: 10, 800
step or supervisor node is correctly 384
00: 07: 7, 990 --> 00: 07: 10, 800 385
00: 07: 8, 000 --> 00: 07: 12, 800
passing it on to the question answering 386
00: 07: 10, 790 --> 00: 07: 12, 800 387
00: 07: 10, 800 --> 00: 07: 14, 319
subgraph and the final strategy we're 388
00: 07: 12, 790 --> 00: 07: 14, 319 389
00: 07: 12, 800 --> 00: 07: 16, 840
going to use is going to look 390
00: 07: 14, 309 --> 00: 07: 16, 840 391
00: 07: 14, 319 --> 00: 07: 18, 960
at the entire trajectory or path that 392
00: 07: 16, 830 --> 00: 07: 18, 960 393
00: 07: 16, 840 --> 00: 07: 21, 800
the agent follows when answering some 394
00: 07: 18, 950 --> 00: 07: 21, 800 395
00: 07: 18, 960 --> 00: 07: 23, 639
query and ensure that it matches the 396
00: 07: 21, 790 --> 00: 07: 23, 639 397
00: 07: 21, 800 --> 00: 07: 25, 759
optimal or ideal trajectory we'd it 398
00: 07: 23, 629 --> 00: 07: 25, 759 399
00: 07: 23, 639 --> 00: 07: 25, 759
to 400
00: 07: 26, 309 --> 00: aN: NaN, NaN 401
00: 07: 26, 319 --> 00: 07: 32, 720
follow so we're going to run these 402
00: 07: 28, 909 --> 00: 07: 32, 720 403
00: 07: 28, 919 --> 00: 07: 35, 120
three Valu strategies using the lsmith 404
00: 07: 32, 710 --> 00: 07: 35, 120 405
00: 07: 32, 720 --> 00: 07: 37, 199
SDK and before we're able to run these 406
00: 07: 35, 110 --> 00: 07: 37, 199 407
00: 07: 35, 120 --> 00: 07: 41, 000
evaluations we need to Define three 408
00: 07: 37, 189 --> 00: 07: 41, 000 409
00: 07: 37, 199 --> 00: 07: 42, 560
things the first is a golden data set 410
00: 07: 40, 990 --> 00: 07: 42, 560 411
00: 07: 41, 000 --> 00: 07: 45, 199
and this golden data set is going to 412
00: 07: 42, 550 --> 00: 07: 45, 199 413
00: 07: 42, 560 --> 00: 07: 48, 360
vary based on the strategy of evolation 414
00: 07: 45, 189 --> 00: 07: 48, 360 415
00: 07: 45, 199 --> 00: 07: 50, 919
we're using for example if we're putting 416
00: 07: 48, 350 --> 00: 07: 50, 919 417
00: 07: 48, 360 --> 00: 07: 54, 159
together golden data set for the final 418
00: 07: 50, 909 --> 00: 07: 54, 159 419
00: 07: 50, 919 --> 00: 07: 55, 520
output accuracy evaluation strategy 420
00: 07: 54, 149 --> 00: 07: 55, 520 421
00: 07: 54, 159 --> 00: 07: 57, 360
we're going to want to make sure our 422
00: 07: 55, 510 --> 00: 07: 57, 360 423
00: 07: 55, 520 --> 00: 07: 59, 879
golden data set has some number of 424
00: 07: 57, 350 --> 00: 07: 59, 879 425
00: 07: 57, 360 --> 00: 08: 2, 560
inputs and outputs the input are going 426
00: 07: 59, 869 --> 00: 08: 2, 560 427
00: 07: 59, 879 --> 00: 08: 5, 039
to be example queries or questions that 428
00: 08: 2, 550 --> 00: 08: 5, 039 429
00: 08: 2, 560 --> 00: 08: 8, 039
a customer will ask our customer support 430
00: 08: 5, 029 --> 00: 08: 8, 039 431
00: 08: 5, 039 --> 00: 08: 10, 280
agent and our outputs will be really 432
00: 08: 8, 029 --> 00: 08: 10, 280 433
00: 08: 8, 039 --> 00: 08: 13, 240
high quality accurate responses that 434
00: 08: 10, 270 --> 00: 08: 13, 240 435
00: 08: 10, 280 --> 00: 08: 15, 159
we'd love to see our agent make in 436
00: 08: 13, 230 --> 00: 08: 15, 159 437
00: 08: 13, 240 --> 00: 08: 17, 479
production now if we were instead 438
00: 08: 15, 149 --> 00: 08: 17, 479 439
00: 08: 15, 159 --> 00: 08: 19, 759
conducting that single step evaluation 440
00: 08: 17, 469 --> 00: 08: 19, 759 441
00: 08: 17, 479 --> 00: 08: 21, 479
strategy we'd want our golden data set 442
00: 08: 19, 749 --> 00: 08: 21, 479 443
00: 08: 19, 759 --> 00: 08: 22, 800
to still have inputs that are questions 444
00: 08: 21, 469 --> 00: 08: 22, 800 445
00: 08: 21, 479 --> 00: 08: 25, 960
or queries that could come from a 446
00: 08: 22, 790 --> 00: 08: 25, 960 447
00: 08: 22, 800 --> 00: 08: 29, 800
customer to the agent but now we want 448
00: 08: 25, 950 --> 00: 08: 29, 800 449
00: 08: 25, 960 --> 00: 08: 31, 440
our outputs to be the expected subgraph 450
00: 08: 29, 790 --> 00: 08: 31, 440 451
00: 08: 29, 800 --> 00: 08: 33, 880
that the intent classification or 452
00: 08: 31, 430 --> 00: 08: 33, 880 453
00: 08: 31, 440 --> 00: 08: 35, 159
supervisor node would route to when it 454
00: 08: 33, 870 --> 00: 08: 35, 159 455
00: 08: 33, 880 --> 00: 08: 37, 599
receives that 456
00: 08: 35, 149 --> 00: 08: 37, 599 457
00: 08: 35, 159 --> 00: 08: 40, 080
query so this golden data set will 458
00: 08: 37, 589 --> 00: 08: 40, 080 459
00: 08: 37, 599 --> 00: 08: 41, 800
vary based on the evaluation strategy 460
00: 08: 40, 070 --> 00: 08: 41, 800 461
00: 08: 40, 080 --> 00: 08: 43, 800
but at a high level the inputs will be 462
00: 08: 41, 790 --> 00: 08: 43, 800 463
00: 08: 41, 800 --> 00: 08: 45, 640
questions from customers to the agent 464
00: 08: 43, 790 --> 00: 08: 45, 640 465
00: 08: 43, 800 --> 00: 08: 48, 040
and the outputs will be the expected 466
00: 08: 45, 630 --> 00: 08: 48, 040 467
00: 08: 45, 640 --> 00: 08: 49, 880
Behavior or response from the 468
00: 08: 48, 030 --> 00: 08: 49, 880 469
00: 08: 48, 040 --> 00: 08: 51, 480
agent the second thing we're going to 470
00: 08: 49, 870 --> 00: 08: 51, 480 471
00: 08: 49, 880 --> 00: 08: 53, 480
Define is our application 472
00: 08: 51, 470 --> 00: 08: 53, 480 473
00: 08: 51, 480 --> 00: 08: 55, 000
lric so for the sake of this 474
00: 08: 53, 470 --> 00: 08: 55, 000 475
00: 08: 53, 480 --> 00: 08: 56, 680
demonstration the application logic we 476
00: 08: 54, 990 --> 00: 08: 56, 680 477
00: 08: 55, 000 --> 00: 08: 59, 959
evaluating is just the customer support 478
00: 08: 56, 670 --> 00: 08: 59, 959 479
00: 08: 56, 680 --> 00: 09: 1, 160
agent I've built with Lang graph 480
00: 08: 59, 949 --> 00: 09: 1, 160 481
00: 08: 59, 959 --> 00: 09: 4, 320
and the last thing we're going to find 482
00: 09: 1, 150 --> 00: 09: 4, 320 483
00: 09: 1, 160 --> 00: 09: 5, 720
here is our evaluators our evaluators 484
00: 09: 4, 310 --> 00: 09: 5, 720 485
00: 09: 4, 320 --> 00: 09: 8, 040
are also going to vary based on the 486
00: 09: 5, 710 --> 00: 09: 8, 040 487
00: 09: 5, 720 --> 00: 09: 10, 640
evalu based on the evaluation strategy 488
00: 09: 8, 030 --> 00: 09: 10, 640 489
00: 09: 8, 040 --> 00: 09: 12, 920
we're employing if we're conducting an 490
00: 09: 10, 630 --> 00: 09: 12, 920 491
00: 09: 10, 640 --> 00: 09: 15, 440
evaluation on the accuracy of the final 492
00: 09: 12, 910 --> 00: 09: 15, 440 493
00: 09: 12, 920 --> 00: 09: 18, 079
output we'd likely want our evaluator to 494
00: 09: 15, 430 --> 00: 09: 18, 079 495
00: 09: 15, 440 --> 00: 09: 21, 120
be some Allen judge that can assess the 496
00: 09: 18, 069 --> 00: 09: 21, 120 497
00: 09: 18, 079 --> 00: 09: 23, 079
accuracy of our agent's output relative 498
00: 09: 21, 110 --> 00: 09: 23, 079 499
00: 09: 21, 120 --> 00: 09: 24, 600
to some reference some reference or 500
00: 09: 23, 069 --> 00: 09: 24, 600 501
00: 09: 23, 079 --> 00: 09: 27, 079
ground truth 502
00: 09: 24, 590 --> 00: 09: 27, 079 503
00: 09: 24, 600 --> 00: 09: 29, 839
output if the evaluation strategy we're 504
00: 09: 27, 069 --> 00: 09: 29, 839 505
00: 09: 27, 079 --> 00: 09: 31, 839
employing is single step to 506
00: 09: 29, 829 --> 00: 09: 31, 839 507
00: 09: 29, 839 --> 00: 09: 34, 600
assessing whether our supervisor node is 508
00: 09: 31, 829 --> 00: 09: 34, 600 509
00: 09: 31, 839 --> 00: 09: 36, 040
routing queries to the correct subgraph 510
00: 09: 34, 590 --> 00: 09: 36, 040 511
00: 09: 34, 600 --> 00: 09: 39, 040
we'd want to maybe bring in some htic 512
00: 09: 36, 030 --> 00: 09: 39, 040 513
00: 09: 36, 040 --> 00: 09: 41, 240
code and make sure that whichever 514
00: 09: 39, 030 --> 00: 09: 41, 240 515
00: 09: 39, 040 --> 00: 09: 47, 000
subgraph our agent routed a specific 516
00: 09: 41, 230 --> 00: 09: 47, 000 517
00: 09: 41, 240 --> 00: 09: 51, 240
query to matches the ideal or accurate 518
00: 09: 46, 990 --> 00: 09: 51, 240 519
00: 09: 47, 000 --> 00: 09: 53, 440
subgraph awesome and all three of these 520
00: 09: 51, 230 --> 00: 09: 53, 440 521
00: 09: 51, 240 --> 00: 09: 55, 640
components are going to tie together 522
00: 09: 53, 430 --> 00: 09: 55, 640 523
00: 09: 53, 440 --> 00: 09: 57, 480
when we run our experiment or 524
00: 09: 55, 630 --> 00: 09: 57, 480 525
00: 09: 55, 640 --> 00: 09: 59, 839
evaluation with the lsmith 526
00: 09: 57, 470 --> 00: 09: 59, 839 527
00: 09: 57, 480 --> 00: 10: 2, 160
SDK when we run our 528
00: 09: 59, 829 --> 00: 10: 2, 160 529
00: 09: 59, 839 --> 00: 10: 3, 880
evaluation blanks Smith SDK will take 530
00: 10: 2, 150 --> 00: 10: 3, 880 531
00: 10: 2, 160 --> 00: 10: 6, 040
our application 532
00: 10: 3, 870 --> 00: 10: 6, 040 533
00: 10: 3, 880 --> 00: 10: 7, 760
logic and run it with the inputs from 534
00: 10: 6, 030 --> 00: 10: 7, 760 535
00: 10: 6, 040 --> 00: 10: 10, 399
our golden data 536
00: 10: 7, 750 --> 00: 10: 10, 399 537
00: 10: 7, 760 --> 00: 10: 12, 959
set this will generate some new 538
00: 10: 10, 389 --> 00: 10: 12, 959 539
00: 10: 10, 399 --> 00: 10: 15, 079
outputs that will then get scored 540
00: 10: 12, 949 --> 00: 10: 15, 079 541
00: 10: 12, 959 --> 00: 10: 18, 800
relative to the outputs in our ground 542
00: 10: 15, 069 --> 00: 10: 18, 800 543
00: 10: 15, 079 --> 00: 10: 20, 600
truth or golden data set by some 544
00: 10: 18, 790 --> 00: 10: 20, 600 545
00: 10: 18, 800 --> 00: 10: 23, 399
evaluators and so let's walk 546
00: 10: 20, 590 --> 00: 10: 23, 399 547
00: 10: 20, 600 --> 00: 10: 26, 360
through some spe some specific 548
00: 10: 23, 389 --> 00: 10: 26, 360 549
00: 10: 23, 399 --> 00: 10: 28, 120
examples so if we were to be evaluating 550
00: 10: 26, 350 --> 00: 10: 28, 120 551
00: 10: 26, 360 --> 00: 10: 30, 360
the final response of our agent for 552
00: 10: 28, 110 --> 00: 10: 30, 360 553
00: 10: 28, 120 --> 00: 10: 32, 000
accuracy 554
00: 10: 30, 350 --> 00: 10: 32, 000 555
00: 10: 30, 360 --> 00: 10: 35, 079
what will happen when we run our 556
00: 10: 31, 990 --> 00: 10: 35, 079 557
00: 10: 32, 000 --> 00: 10: 37, 639
experiment is we'll take the application 558
00: 10: 35, 069 --> 00: 10: 37, 639 559
00: 10: 35, 079 --> 00: 10: 39, 240
logic or our customer support agent run 560
00: 10: 37, 629 --> 00: 10: 39, 240 561
00: 10: 37, 639 --> 00: 10: 41, 519
it over the inputs of our golden data 562
00: 10: 39, 230 --> 00: 10: 41, 519 563
00: 10: 39, 240 --> 00: 10: 43, 639
set which are just queries that we 564
00: 10: 41, 509 --> 00: 10: 43, 639 565
00: 10: 41, 519 --> 00: 10: 44, 880
defined earlier queries or questions 566
00: 10: 43, 629 --> 00: 10: 44, 880 567
00: 10: 43, 639 --> 00: 10: 46, 959
from 568
00: 10: 44, 870 --> 00: 10: 46, 959 569
00: 10: 44, 880 --> 00: 10: 50, 040
customers these new outputs will be 570
00: 10: 46, 949 --> 00: 10: 50, 040 571
00: 10: 46, 959 --> 00: 10: 52, 560
scored by an Alum judge this Alum judge 572
00: 10: 50, 030 --> 00: 10: 52, 560 573
00: 10: 50, 040 --> 00: 10: 55, 079
will assess how accurate these 574
00: 10: 52, 550 --> 00: 10: 55, 079 575
00: 10: 52, 560 --> 00: 10: 57, 160
new outputs generated by our agent are 576
00: 10: 55, 069 --> 00: 10: 57, 160 577
00: 10: 55, 079 --> 00: 11: 0, 680
relative to the reference outputs in our 578
00: 10: 57, 150 --> 00: 11: 0, 680 579
00: 10: 57, 160 --> 00: 11: 0, 680
golden data set 580
00: 11: 1, 069 --> 00: aN: NaN, NaN 581
00: 11: 1, 079 --> 00: 11: 6, 360
the next evaluation strategy is the 582
00: 11: 2, 790 --> 00: 11: 6, 360 583
00: 11: 2, 800 --> 00: 11: 7, 920
single step eval evaluation strategy so 584
00: 11: 6, 350 --> 00: 11: 7, 920 585
00: 11: 6, 360 --> 00: 11: 11, 240
when we run this experiment with length 586
00: 11: 7, 910 --> 00: 11: 11, 240 587
00: 11: 7, 920 --> 00: 11: 13, 480
of SDK again we'll be running the 588
00: 11: 11, 230 --> 00: 11: 13, 480 589
00: 11: 11, 240 --> 00: 11: 16, 399
customer support agent over the inputs 590
00: 11: 13, 470 --> 00: 11: 16, 399 591
00: 11: 13, 480 --> 00: 11: 18, 639
in our golden data set and instead this 592
00: 11: 16, 389 --> 00: 11: 18, 639 593
00: 11: 16, 399 --> 00: 11: 20, 920
time our evaluator will be some ver to 594
00: 11: 18, 629 --> 00: 11: 20, 920 595
00: 11: 18, 639 --> 00: 11: 24, 040
code that just makes that makes sure 596
00: 11: 20, 910 --> 00: 11: 24, 040 597
00: 11: 20, 920 --> 00: 11: 26, 680
that in our runs the runs that were 598
00: 11: 24, 030 --> 00: 11: 26, 680 599
00: 11: 24, 040 --> 00: 11: 29, 760
made by our customer support 600
00: 11: 26, 670 --> 00: 11: 29, 760 601
00: 11: 26, 680 --> 00: 11: 31, 880
agent that we routed to the corre 602
00: 11: 29, 750 --> 00: 11: 31, 880 603
00: 11: 29, 760 --> 00: 11: 33, 959
subgraph and what we'll do is 604
00: 11: 31, 870 --> 00: 11: 33, 959 605
00: 11: 31, 880 --> 00: 11: 35, 920
we'll just double check that whichever 606
00: 11: 33, 949 --> 00: 11: 35, 920 607
00: 11: 33, 959 --> 00: 11: 38, 760
subgraph we routed to In Those runs by 608
00: 11: 35, 910 --> 00: 11: 38, 760 609
00: 11: 35, 920 --> 00: 11: 40, 160
our customer for agent matches the 610
00: 11: 38, 750 --> 00: 11: 40, 160 611
00: 11: 38, 760 --> 00: 11: 42, 360
the name of the subgraph in our 612
00: 11: 40, 150 --> 00: 11: 42, 360 613
00: 11: 40, 160 --> 00: 11: 44, 600
reference output inside of our golden 614
00: 11: 42, 350 --> 00: 11: 44, 600 615
00: 11: 42, 360 --> 00: 11: 44, 600
data 616
00: 11: 45, 110 --> 00: aN: NaN, NaN 617
00: 11: 45, 120 --> 00: 11: 49, 519
set and our third and last evaluation 618
00: 11: 47, 470 --> 00: 11: 49, 519 619
00: 11: 47, 480 --> 00: 11: 52, 240
strategy is 620
00: 11: 49, 509 --> 00: 11: 52, 240 621
00: 11: 49, 519 --> 00: 11: 53, 839
trajectory again we'll be running our 622
00: 11: 52, 230 --> 00: 11: 53, 839 623
00: 11: 52, 240 --> 00: 11: 57, 040
customer support agent over the impet of 624
00: 11: 53, 829 --> 00: 11: 57, 040 625
00: 11: 53, 839 --> 00: 11: 58, 959
golden data set and within these runs 626
00: 11: 57, 030 --> 00: 11: 58, 959 627
00: 11: 57, 040 --> 00: 12: 1, 320
we'll make sure that the trajectory the 628
00: 11: 58, 949 --> 00: 12: 1, 320 629
00: 11: 58, 959 --> 00: 12: 4, 320
agent it followed or the path it 630
00: 12: 1, 310 --> 00: 12: 4, 320 631
00: 12: 1, 320 --> 00: 12: 7, 279
followed matches the path we defined our 632
00: 12: 4, 310 --> 00: 12: 7, 279 633
00: 12: 4, 320 --> 00: 12: 9, 519
reference output which is optimal and 634
00: 12: 7, 269 --> 00: 12: 9, 519 635
00: 12: 7, 279 --> 00: 12: 11, 560
something we'd love to see in 636
00: 12: 9, 509 --> 00: 12: 11, 560 637
00: 12: 9, 519 --> 00: 12: 13, 519
production great now let's hop 638
00: 12: 11, 550 --> 00: 12: 13, 519 639
00: 12: 11, 560 --> 00: 12: 15, 000
in the code and show off how you can 640
00: 12: 13, 509 --> 00: 12: 15, 000 641
00: 12: 13, 519 --> 00: 12: 17, 360
implement this evaluation with the 642
00: 12: 14, 990 --> 00: 12: 17, 360 643
00: 12: 15, 000 --> 00: 12: 20, 519
length with 644
00: 12: 17, 350 --> 00: 12: 20, 519 645
00: 12: 17, 360 --> 00: 12: 23, 199
SDK great we're in the notebook before I 646
00: 12: 20, 509 --> 00: 12: 23, 199 647
00: 12: 20, 519 --> 00: 12: 25, 440
go into the evaluation code I'm first 648
00: 12: 23, 189 --> 00: 12: 25, 440 649
00: 12: 23, 199 --> 00: 12: 27, 360
going to go over very briefly the code 650
00: 12: 25, 430 --> 00: 12: 27, 360 651
00: 12: 25, 440 --> 00: 12: 29, 800
that underpins the customer support 652
00: 12: 27, 350 --> 00: 12: 29, 800 653
00: 12: 27, 360 --> 00: 12: 31, 680
agent now this video is primarily 654
00: 12: 29, 790 --> 00: 12: 31, 680 655
00: 12: 29, 800 --> 00: 12: 33, 680
focused on evaluating the agent instead 656
00: 12: 31, 670 --> 00: 12: 33, 680 657
00: 12: 31, 680 --> 00: 12: 36, 040
of building the agent so I'm not going 658
00: 12: 33, 670 --> 00: 12: 36, 040 659
00: 12: 33, 680 --> 00: 12: 37, 560
to walk through this code line by line 660
00: 12: 36, 030 --> 00: 12: 37, 560 661
00: 12: 36, 040 --> 00: 12: 39, 600
but I'll attach this notebook to the 662
00: 12: 37, 550 --> 00: 12: 39, 600 663
00: 12: 37, 560 --> 00: 12: 42, 639
description of the video so you all can 664
00: 12: 39, 590 --> 00: 12: 42, 639 665
00: 12: 39, 600 --> 00: 12: 43, 680
go deep into it on your own time as you 666
00: 12: 42, 629 --> 00: 12: 43, 680 667
00: 12: 42, 639 --> 00: 12: 46, 000
probably already saw from the 668
00: 12: 43, 670 --> 00: 12: 46, 000 669
00: 12: 43, 680 --> 00: 12: 48, 160
architecture and Lang graph Studio this 670
00: 12: 45, 990 --> 00: 12: 48, 160 671
00: 12: 46, 000 --> 00: 12: 51, 320
agent has three main 672
00: 12: 48, 150 --> 00: 12: 51, 320 673
00: 12: 48, 160 --> 00: 12: 53, 800
components this agent has a refund 674
00: 12: 51, 310 --> 00: 12: 53, 800 675
00: 12: 51, 320 --> 00: 12: 56, 399
subgraph this subgraph handles queries 676
00: 12: 53, 790 --> 00: 12: 56, 399 677
00: 12: 53, 800 --> 00: 12: 58, 120
related to customer refunds and inside 678
00: 12: 56, 389 --> 00: 12: 58, 120 679
00: 12: 56, 399 --> 00: 13: 1, 760
of this refund subgraph there's three 680
00: 12: 58, 110 --> 00: 13: 1, 760 681
00: 12: 58, 120 --> 00: 13: 4, 040
notes the first node gather info prompts 682
00: 13: 1, 750 --> 00: 13: 4, 040 683
00: 13: 1, 760 --> 00: 13: 6, 000
the customer for additional information 684
00: 13: 4, 030 --> 00: 13: 6, 000 685
00: 13: 4, 040 --> 00: 13: 8, 880
if we don't have enough context on the 686
00: 13: 5, 990 --> 00: 13: 8, 880 687
00: 13: 6, 000 --> 00: 13: 12, 519
customer to execute and process a 688
00: 13: 8, 870 --> 00: 13: 12, 519 689
00: 13: 8, 880 --> 00: 13: 14, 279
refund the second node lookup is 690
00: 13: 12, 509 --> 00: 13: 14, 279 691
00: 13: 12, 519 --> 00: 13: 16, 760
executed when we have enough information 692
00: 13: 14, 269 --> 00: 13: 16, 760 693
00: 13: 14, 279 --> 00: 13: 18, 519
to identify the customer in the database 694
00: 13: 16, 750 --> 00: 13: 18, 519 695
00: 13: 16, 760 --> 00: 13: 21, 760
but not enough information to 696
00: 13: 18, 509 --> 00: 13: 21, 760 697
00: 13: 18, 519 --> 00: 13: 23, 880
process a specific refund so 698
00: 13: 21, 750 --> 00: 13: 23, 880 699
00: 13: 21, 760 --> 00: 13: 26, 399
what the lookup node will do is take the 700
00: 13: 23, 870 --> 00: 13: 26, 399 701
00: 13: 23, 880 --> 00: 13: 27, 920
customer's identify information this is 702
00: 13: 26, 389 --> 00: 13: 27, 920 703
00: 13: 26, 399 --> 00: 13: 29, 720
the customer's first name last name and 704
00: 13: 27, 910 --> 00: 13: 29, 720 705
00: 13: 27, 920 --> 00: 13: 31, 560
phone number 706
00: 13: 29, 710 --> 00: 13: 31, 560 707
00: 13: 29, 720 --> 00: 13: 34, 440
and read from the database using some 708
00: 13: 31, 550 --> 00: 13: 34, 440 709
00: 13: 31, 560 --> 00: 13: 36, 000
SQL all of their Associated invoices or 710
00: 13: 34, 430 --> 00: 13: 36, 000 711
00: 13: 34, 440 --> 00: 13: 38, 199
purchases with the music store in the 712
00: 13: 35, 990 --> 00: 13: 38, 199 713
00: 13: 36, 000 --> 00: 13: 41, 639
past and return a message to the user 714
00: 13: 38, 189 --> 00: 13: 41, 639 715
00: 13: 38, 199 --> 00: 13: 44, 079
that says hey so and so we were able to 716
00: 13: 41, 629 --> 00: 13: 44, 079 717
00: 13: 41, 639 --> 00: 13: 46, 399
find your records in the database here 718
00: 13: 44, 069 --> 00: 13: 46, 399 719
00: 13: 44, 079 --> 00: 13: 48, 279
are the invoices and past purchases 720
00: 13: 46, 389 --> 00: 13: 48, 279 721
00: 13: 46, 399 --> 00: 13: 50, 800
we've seen you've had with the 722
00: 13: 48, 269 --> 00: 13: 50, 800 723
00: 13: 48, 279 --> 00: 13: 54, 199
store which ones would you a refund 724
00: 13: 50, 790 --> 00: 13: 54, 199 725
00: 13: 50, 800 --> 00: 13: 56, 680
for and once this refund subgraph gets 726
00: 13: 54, 189 --> 00: 13: 56, 680 727
00: 13: 54, 199 --> 00: 13: 58, 639
that context we're able to use the last 728
00: 13: 56, 670 --> 00: 13: 58, 639 729
00: 13: 56, 680 --> 00: 14: 1, 759
node which is the refund node and this 730
00: 13: 58, 629 --> 00: 14: 1, 759 731
00: 13: 58, 639 --> 00: 14: 3, 759
node writes to the database using SQL to 732
00: 14: 1, 749 --> 00: 14: 3, 759 733
00: 14: 1, 759 --> 00: 14: 6, 399
process a customer refund once we're 734
00: 14: 3, 749 --> 00: 14: 6, 399 735
00: 14: 3, 759 --> 00: 14: 8, 880
able to both identify the customer 736
00: 14: 6, 389 --> 00: 14: 8, 880 737
00: 14: 6, 399 --> 00: 14: 10, 959
and have a specified invoice ID that 738
00: 14: 8, 870 --> 00: 14: 10, 959 739
00: 14: 8, 880 --> 00: 14: 13, 440
they would a refund 740
00: 14: 10, 949 --> 00: 14: 13, 440 741
00: 14: 10, 959 --> 00: 14: 15, 360
for so that's the refund 742
00: 14: 13, 430 --> 00: 14: 15, 360 743
00: 14: 13, 440 --> 00: 14: 16, 560
subgraph again not going to go through 744
00: 14: 15, 350 --> 00: 14: 16, 560 745
00: 14: 15, 360 --> 00: 14: 19, 160
the code so just going to scroll 746
00: 14: 16, 550 --> 00: 14: 19, 160 747
00: 14: 16, 560 --> 00: 14: 20, 560
straight through here feel free to look 748
00: 14: 19, 150 --> 00: 14: 20, 560 749
00: 14: 19, 160 --> 00: 14: 22, 639
at on your own 750
00: 14: 20, 550 --> 00: 14: 22, 639 751
00: 14: 20, 560 --> 00: 14: 25, 120
time the second component is the 752
00: 14: 22, 629 --> 00: 14: 25, 120 753
00: 14: 22, 639 --> 00: 14: 26, 720
question answering subgraph the subgraph 754
00: 14: 25, 110 --> 00: 14: 26, 720 755
00: 14: 25, 120 --> 00: 14: 29, 360
is meant to handle queries related to 756
00: 14: 26, 710 --> 00: 14: 29, 360 757
00: 14: 26, 720 --> 00: 14: 31, 279
the products and offerings of a store 758
00: 14: 29, 350 --> 00: 14: 31, 279 759
00: 14: 29, 360 --> 00: 14: 33, 000
and this subgraph follows the react 760
00: 14: 31, 269 --> 00: 14: 33, 000 761
00: 14: 31, 279 --> 00: 14: 34, 320
agent architecture if you aren't 762
00: 14: 32, 990 --> 00: 14: 34, 320 763
00: 14: 33, 000 --> 00: 14: 37, 360
familiar with what the react agent 764
00: 14: 34, 310 --> 00: 14: 37, 360 765
00: 14: 34, 320 --> 00: 14: 39, 519
architecture is view the link I'm 766
00: 14: 37, 350 --> 00: 14: 39, 519 767
00: 14: 37, 360 --> 00: 14: 43, 560
attaching to the description of this 768
00: 14: 39, 509 --> 00: 14: 43, 560 769
00: 14: 39, 519 --> 00: 14: 45, 959
video but all the subgraph is an llm 770
00: 14: 43, 550 --> 00: 14: 45, 959 771
00: 14: 43, 560 --> 00: 14: 47, 800
with access to certain tools these tools 772
00: 14: 45, 949 --> 00: 14: 47, 800 773
00: 14: 45, 959 --> 00: 14: 51, 120
allow it to read from the database using 774
00: 14: 47, 790 --> 00: 14: 51, 120 775
00: 14: 47, 800 --> 00: 14: 53, 839
SQL and thus answer questions such as 776
00: 14: 51, 110 --> 00: 14: 53, 839 777
00: 14: 51, 120 --> 00: 14: 56, 800
hey what songs does the store have what 778
00: 14: 53, 829 --> 00: 14: 56, 800 779
00: 14: 53, 839 --> 00: 14: 59, 759
albums are you selling I'm looking for a 780
00: 14: 56, 790 --> 00: 14: 59, 759 781
00: 14: 56, 800 --> 00: 15: 2, 160
song by this artist what which songs by 782
00: 14: 59, 749 --> 00: 15: 2, 160 783
00: 14: 59, 759 --> 00: 15: 6, 199
them are you selling at the 784
00: 15: 2, 150 --> 00: 15: 6, 199 785
00: 15: 2, 160 --> 00: 15: 9, 839
store and these two subgraphs are pulled 786
00: 15: 6, 189 --> 00: 15: 9, 839 787
00: 15: 6, 199 --> 00: 15: 12, 880
in to another 788
00: 15: 9, 829 --> 00: 15: 12, 880 789
00: 15: 9, 839 --> 00: 15: 15, 120
graph and the way that we end 790
00: 15: 12, 870 --> 00: 15: 15, 120 791
00: 15: 12, 880 --> 00: 15: 17, 360
up invoking either of these 792
00: 15: 15, 110 --> 00: 15: 17, 360 793
00: 15: 15, 120 --> 00: 15: 19, 600
subgraphs is through this intent 794
00: 15: 17, 350 --> 00: 15: 19, 600 795
00: 15: 17, 360 --> 00: 15: 22, 519
classifier or supervisor node that we 796
00: 15: 19, 590 --> 00: 15: 22, 519 797
00: 15: 19, 600 --> 00: 15: 24, 360
have at the at the top of our 798
00: 15: 22, 509 --> 00: 15: 24, 360 799
00: 15: 22, 519 --> 00: 15: 25, 880
architecture and so this intent 800
00: 15: 24, 350 --> 00: 15: 25, 880 801
00: 15: 24, 360 --> 00: 15: 27, 320
classifier supervisor node 802
00: 15: 25, 870 --> 00: 15: 27, 320 803
00: 15: 25, 880 --> 00: 15: 29, 959
looks at the query that the customer 804
00: 15: 27, 310 --> 00: 15: 29, 959 805
00: 15: 27, 320 --> 00: 15: 32, 000
asked determines what whether it's about 806
00: 15: 29, 949 --> 00: 15: 32, 000 807
00: 15: 29, 959 --> 00: 15: 33, 720
a customer refund or the products and 808
00: 15: 31, 990 --> 00: 15: 33, 720 809
00: 15: 32, 000 --> 00: 15: 36, 399
offerings of the store and routes the 810
00: 15: 33, 710 --> 00: 15: 36, 399 811
00: 15: 33, 720 --> 00: 15: 37, 880
query there and we already covered this 812
00: 15: 36, 389 --> 00: 15: 37, 880 813
00: 15: 36, 399 --> 00: 15: 41, 319
but the last node just cleans up our 814
00: 15: 37, 870 --> 00: 15: 41, 319 815
00: 15: 37, 880 --> 00: 15: 44, 880
state and returns a final message to the 816
00: 15: 41, 309 --> 00: 15: 44, 880 817
00: 15: 41, 319 --> 00: 15: 46, 839
user great so that's the that's the 818
00: 15: 44, 870 --> 00: 15: 46, 839 819
00: 15: 44, 880 --> 00: 15: 49, 199
general gist of our customer support 820
00: 15: 46, 829 --> 00: 15: 49, 199 821
00: 15: 46, 839 --> 00: 15: 52, 360
agent feel free to hop in the code in 822
00: 15: 49, 189 --> 00: 15: 52, 360 823
00: 15: 49, 199 --> 00: 15: 53, 399
the description linked below and now 824
00: 15: 52, 350 --> 00: 15: 53, 399 825
00: 15: 52, 360 --> 00: 15: 56, 079
I'm going to dive into 826
00: 15: 53, 389 --> 00: 15: 56, 079 827
00: 15: 53, 399 --> 00: 15: 58, 720
evaluating this agent with lsmith 828
00: 15: 56, 069 --> 00: 15: 58, 720 829
00: 15: 56, 079 --> 00: 16: 1, 040
SDK let's evaluate our agent with lsmith 830
00: 15: 58, 710 --> 00: 16: 1, 040 831
00: 15: 58, 720 --> 00: 16: 2, 360
SD K if you're not familiar with lsmith 832
00: 16: 1, 030 --> 00: 16: 2, 360 833
00: 16: 1, 040 --> 00: 16: 5, 079
it's a platform that helps you build 834
00: 16: 2, 350 --> 00: 16: 5, 079 835
00: 16: 2, 360 --> 00: 16: 6, 880
production ready LM applications 836
00: 16: 5, 069 --> 00: 16: 6, 880 837
00: 16: 5, 079 --> 00: 16: 9, 279
discussing lsmith in detail is a bit out 838
00: 16: 6, 870 --> 00: 16: 9, 279 839
00: 16: 6, 880 --> 00: 16: 11, 600
of scope for this video instead I'll 840
00: 16: 9, 269 --> 00: 16: 11, 600 841
00: 16: 9, 279 --> 00: 16: 13, 199
just link some docs and resources below 842
00: 16: 11, 590 --> 00: 16: 13, 199 843
00: 16: 11, 600 --> 00: 16: 14, 040
so if you want to learn about link Smith 844
00: 16: 13, 189 --> 00: 16: 14, 040 845
00: 16: 13, 199 --> 00: 16: 16, 279
you 846
00: 16: 14, 030 --> 00: 16: 16, 279 847
00: 16: 14, 040 --> 00: 16: 19, 600
can the first evaluation we're going to 848
00: 16: 16, 269 --> 00: 16: 19, 600 849
00: 16: 16, 279 --> 00: 16: 21, 360
run will assess how accurate the answer 850
00: 16: 19, 590 --> 00: 16: 21, 360 851
00: 16: 19, 600 --> 00: 16: 22, 759
generated by my customer support agent 852
00: 16: 21, 350 --> 00: 16: 22, 759 853
00: 16: 21, 360 --> 00: 16: 24, 480
when it receives some query from a 854
00: 16: 22, 749 --> 00: 16: 24, 480 855
00: 16: 22, 759 --> 00: 16: 26, 800
customer 856
00: 16: 24, 470 --> 00: 16: 26, 800 857
00: 16: 24, 480 --> 00: 16: 28, 600
is and to run this evaluation we're 858
00: 16: 26, 790 --> 00: 16: 28, 600 859
00: 16: 26, 800 --> 00: 16: 30, 959
first going to need to create a golden 860
00: 16: 28, 590 --> 00: 16: 30, 959 861
00: 16: 28, 600 --> 00: 16: 32, 600
data set and as you can see from my 862
00: 16: 30, 949 --> 00: 16: 32, 600 863
00: 16: 30, 959 --> 00: 16: 35, 240
code we're manually creating this golden 864
00: 16: 32, 590 --> 00: 16: 35, 240 865
00: 16: 32, 600 --> 00: 16: 37, 639
data set here and I've already defined 866
00: 16: 35, 230 --> 00: 16: 37, 639 867
00: 16: 35, 240 --> 00: 16: 40, 199
five input output pairs that this data 868
00: 16: 37, 629 --> 00: 16: 40, 199 869
00: 16: 37, 639 --> 00: 16: 42, 600
set will be composed of in each input 870
00: 16: 40, 189 --> 00: 16: 42, 600 871
00: 16: 40, 199 --> 00: 16: 44, 160
out a pair the input will be an example 872
00: 16: 42, 590 --> 00: 16: 44, 160 873
00: 16: 42, 600 --> 00: 16: 47, 000
question that a customer would pose our 874
00: 16: 44, 150 --> 00: 16: 47, 000 875
00: 16: 44, 160 --> 00: 16: 48, 720
customer support agent and the output is 876
00: 16: 46, 990 --> 00: 16: 48, 720 877
00: 16: 47, 000 --> 00: 16: 50, 319
going to be a high quality accurate 878
00: 16: 48, 710 --> 00: 16: 50, 319 879
00: 16: 48, 720 --> 00: 16: 51, 560
response that we'd love to see our agent 880
00: 16: 50, 309 --> 00: 16: 51, 560 881
00: 16: 50, 319 --> 00: 16: 53, 639
produce in 882
00: 16: 51, 550 --> 00: 16: 53, 639 883
00: 16: 51, 560 --> 00: 16: 56, 199
production so in this first input output 884
00: 16: 53, 629 --> 00: 16: 56, 199 885
00: 16: 53, 639 --> 00: 16: 57, 800
pair we can see the input is a question 886
00: 16: 56, 189 --> 00: 16: 57, 800 887
00: 16: 56, 199 --> 00: 17: 1, 680
so how many songs do you have by James 888
00: 16: 57, 790 --> 00: 17: 1, 680 889
00: 16: 57, 800 --> 00: 17: 3, 040
Brown in the output is an accurate 890
00: 17: 1, 670 --> 00: 17: 3, 040 891
00: 17: 1, 680 --> 00: 17: 5, 039
response to that question from our 892
00: 17: 3, 030 --> 00: 17: 5, 039 893
00: 17: 3, 040 --> 00: 17: 7, 559
customer support agent so here the 894
00: 17: 5, 029 --> 00: 17: 7, 559 895
00: 17: 5, 039 --> 00: 17: 10, 520
response is we have 20 songs by James 896
00: 17: 7, 549 --> 00: 17: 10, 520 897
00: 17: 7, 559 --> 00: 17: 12, 720
Brown all we'll be sending this to 898
00: 17: 10, 510 --> 00: 17: 12, 720 899
00: 17: 10, 520 --> 00: 17: 14, 839
lsmith as a data set under the name 900
00: 17: 12, 710 --> 00: 17: 14, 839 901
00: 17: 12, 720 --> 00: 17: 16, 919
chinuk customer service Bo final 902
00: 17: 14, 829 --> 00: 17: 16, 919 903
00: 17: 14, 839 --> 00: 17: 18, 799
response chinuk is the name of the 904
00: 17: 16, 909 --> 00: 17: 18, 799 905
00: 17: 16, 919 --> 00: 17: 21, 480
database that our customer support agent 906
00: 17: 18, 789 --> 00: 17: 21, 480 907
00: 17: 18, 799 --> 00: 17: 23, 480
is hooked up to we'll be sending this 908
00: 17: 21, 470 --> 00: 17: 23, 480 909
00: 17: 21, 480 --> 00: 17: 25, 839
data set to lsmith because s Lang Smith 910
00: 17: 23, 470 --> 00: 17: 25, 839 911
00: 17: 23, 480 --> 00: 17: 29, 240
where we'll be able to view and interact 912
00: 17: 25, 829 --> 00: 17: 29, 240 913
00: 17: 25, 839 --> 00: 17: 30, 720
with the results from our evaluation 914
00: 17: 29, 230 --> 00: 17: 30, 720 915
00: 17: 29, 240 --> 00: 17: 32, 280
all great so that's our buen data 916
00: 17: 30, 710 --> 00: 17: 32, 280 917
00: 17: 30, 720 --> 00: 17: 34, 960
set and we've sent it off to 918
00: 17: 32, 270 --> 00: 17: 34, 960 919
00: 17: 32, 280 --> 00: 17: 36, 559
lsmith now let's move on to step two 920
00: 17: 34, 950 --> 00: 17: 36, 559 921
00: 17: 34, 960 --> 00: 17: 39, 120
which is defining the application logic 922
00: 17: 36, 549 --> 00: 17: 39, 120 923
00: 17: 36, 559 --> 00: 17: 40, 600
that we want to evaluate so because 924
00: 17: 39, 110 --> 00: 17: 40, 600 925
00: 17: 39, 120 --> 00: 17: 43, 000
we're just evaluating our customer 926
00: 17: 40, 590 --> 00: 17: 43, 000 927
00: 17: 40, 600 --> 00: 17: 45, 799
support agent in this 928
00: 17: 42, 990 --> 00: 17: 45, 799 929
00: 17: 43, 000 --> 00: 17: 48, 799
evaluation what we need to do is Define 930
00: 17: 45, 789 --> 00: 17: 48, 799 931
00: 17: 45, 799 --> 00: 17: 51, 840
a Target function called runor graph 932
00: 17: 48, 789 --> 00: 17: 51, 840 933
00: 17: 48, 799 --> 00: 17: 54, 160
runor graph will receive the inputs from 934
00: 17: 51, 830 --> 00: 17: 54, 160 935
00: 17: 51, 840 --> 00: 17: 56, 080
our golden data set when we kick off our 936
00: 17: 54, 150 --> 00: 17: 56, 080 937
00: 17: 54, 160 --> 00: 17: 58, 159
experiment using L spit 938
00: 17: 56, 070 --> 00: 17: 58, 159 939
00: 17: 56, 080 --> 00: 18: 0, 799
SDK and what this target function will 940
00: 17: 58, 149 --> 00: 18: 0, 799 941
00: 17: 58, 159 --> 00: 18: 2, 799
do is just pass in the inputs for 942
00: 18: 0, 789 --> 00: 18: 2, 799 943
00: 18: 0, 799 --> 00: 18: 5, 720
the example customer questions from our 944
00: 18: 2, 789 --> 00: 18: 5, 720 945
00: 18: 2, 799 --> 00: 18: 9, 200
building data set to our customer 946
00: 18: 5, 710 --> 00: 18: 9, 200 947
00: 18: 5, 720 --> 00: 18: 10, 960
support agent to noted by graph here our 948
00: 18: 9, 190 --> 00: 18: 10, 960 949
00: 18: 9, 200 --> 00: 18: 14, 000
customer for agent will take this query 950
00: 18: 10, 950 --> 00: 18: 14, 000 951
00: 18: 10, 960 --> 00: 18: 16, 480
or question generate a response and all 952
00: 18: 13, 990 --> 00: 18: 16, 480 953
00: 18: 14, 000 --> 00: 18: 17, 960
we'll do is return the response and 954
00: 18: 16, 470 --> 00: 18: 17, 960 955
00: 18: 16, 480 --> 00: 18: 20, 440
we'll be plucking the state 956
00: 18: 17, 950 --> 00: 18: 20, 440 957
00: 18: 17, 960 --> 00: 18: 22, 440
value that we have for our agent called 958
00: 18: 20, 430 --> 00: 18: 22, 440 959
00: 18: 20, 440 --> 00: 18: 23, 480
follow-up because it's side of follow-up 960
00: 18: 22, 430 --> 00: 18: 23, 480 961
00: 18: 22, 440 --> 00: 18: 25, 400
that will should be storing 962
00: 18: 23, 470 --> 00: 18: 25, 400 963
00: 18: 23, 480 --> 00: 18: 27, 720
that response that we that we would 964
00: 18: 25, 390 --> 00: 18: 27, 720 965
00: 18: 25, 400 --> 00: 18: 29, 600
return to a user great so that's the 966
00: 18: 27, 710 --> 00: 18: 29, 600 967
00: 18: 27, 720 --> 00: 18: 32, 360
application logic we're about 968
00: 18: 29, 590 --> 00: 18: 32, 360 969
00: 18: 29, 600 --> 00: 18: 34, 520
Vala and now let's define our 970
00: 18: 32, 350 --> 00: 18: 34, 520 971
00: 18: 32, 360 --> 00: 18: 35, 799
evaluator so it's similar to how the 972
00: 18: 34, 510 --> 00: 18: 35, 799 973
00: 18: 34, 520 --> 00: 18: 38, 120
target function that houses our 974
00: 18: 35, 789 --> 00: 18: 38, 120 975
00: 18: 35, 799 --> 00: 18: 40, 159
application logic automatically receives 976
00: 18: 38, 110 --> 00: 18: 40, 159 977
00: 18: 38, 120 --> 00: 18: 42, 120
the inputs from the golden data set when 978
00: 18: 40, 149 --> 00: 18: 42, 120 979
00: 18: 40, 159 --> 00: 18: 45, 159
the experiment is kicked off using links 980
00: 18: 42, 110 --> 00: 18: 45, 159 981
00: 18: 42, 120 --> 00: 18: 46, 640
since SDK our evaluator will 982
00: 18: 45, 149 --> 00: 18: 46, 640 983
00: 18: 45, 159 --> 00: 18: 48, 919
automatically receive the inputs from 984
00: 18: 46, 630 --> 00: 18: 48, 919 985
00: 18: 46, 640 --> 00: 18: 51, 120
the golden data set the outputs 986
00: 18: 48, 909 --> 00: 18: 51, 120 987
00: 18: 48, 919 --> 00: 18: 52, 400
generated by the Target function or my 988
00: 18: 51, 110 --> 00: 18: 52, 400 989
00: 18: 51, 120 --> 00: 18: 54, 799
customer support 990
00: 18: 52, 390 --> 00: 18: 54, 799 991
00: 18: 52, 400 --> 00: 18: 57, 600
agent and the reference output fromal 992
00: 18: 54, 789 --> 00: 18: 57, 600 993
00: 18: 54, 799 --> 00: 18: 59, 440
data set and our evaluator which is 994
00: 18: 57, 590 --> 00: 18: 59, 440 995
00: 18: 57, 600 --> 00: 19: 2, 200
defined inside of this function Final 996
00: 18: 59, 430 --> 00: 19: 2, 200 997
00: 18: 59, 440 --> 00: 19: 5, 200
Answer correct we'll take all three of 998
00: 19: 2, 190 --> 00: 19: 5, 200 999
00: 19: 2, 200 --> 00: 19: 8, 039
these pieces of data and give them to an 1000
00: 19: 5, 190 --> 00: 19: 8, 039 1001
00: 19: 5, 200 --> 00: 19: 10, 520
allen judge and this Alm judge has a 1002
00: 19: 8, 029 --> 00: 19: 10, 520 1003
00: 19: 8, 039 --> 00: 19: 13, 240
system prompt which instructs it to act 1004
00: 19: 10, 510 --> 00: 19: 13, 240 1005
00: 19: 10, 520 --> 00: 19: 15, 000
as a teacher grading a quiz we inform 1006
00: 19: 13, 230 --> 00: 19: 15, 000 1007
00: 19: 13, 240 --> 00: 19: 15, 799
this Alm judge that it will be given it 1008
00: 19: 14, 990 --> 00: 19: 15, 799 1009
00: 19: 15, 000 --> 00: 19: 18, 080
a 1010
00: 19: 15, 789 --> 00: 19: 18, 080 1011
00: 19: 15, 799 --> 00: 19: 20, 640
question in this case the question is 1012
00: 19: 18, 070 --> 00: 19: 20, 640 1013
00: 19: 18, 080 --> 00: 19: 23, 559
just the input from our golden data set 1014
00: 19: 20, 630 --> 00: 19: 23, 559 1015
00: 19: 20, 640 --> 00: 19: 25, 480
the ground truth or correct response 1016
00: 19: 23, 549 --> 00: 19: 25, 480 1017
00: 19: 23, 559 --> 00: 19: 28, 480
which is just the output from our golden 1018
00: 19: 25, 470 --> 00: 19: 28, 480 1019
00: 19: 25, 480 --> 00: 19: 30, 360
data set and the Student Response which 1020
00: 19: 28, 470 --> 00: 19: 30, 360 1021
00: 19: 28, 480 --> 00: 19: 32, 280
is just the answer generated by my 1022
00: 19: 30, 350 --> 00: 19: 32, 280 1023
00: 19: 30, 360 --> 00: 19: 33, 240
customer support agent inside of the 1024
00: 19: 32, 270 --> 00: 19: 33, 240 1025
00: 19: 32, 280 --> 00: 19: 35, 640
target 1026
00: 19: 33, 230 --> 00: 19: 35, 640 1027
00: 19: 33, 240 --> 00: 19: 38, 760
function we'll give this LM judge some 1028
00: 19: 35, 630 --> 00: 19: 38, 760 1029
00: 19: 35, 640 --> 00: 19: 40, 480
more granular details on what denotes a 1030
00: 19: 38, 750 --> 00: 19: 40, 480 1031
00: 19: 38, 760 --> 00: 19: 43, 080
correct Student Response and what 1032
00: 19: 40, 470 --> 00: 19: 43, 080 1033
00: 19: 40, 480 --> 00: 19: 45, 440
denotes inaccurate Student Response and 1034
00: 19: 43, 070 --> 00: 19: 45, 440 1035
00: 19: 43, 080 --> 00: 19: 47, 799
then we'll invoke this Len 1036
00: 19: 45, 430 --> 00: 19: 47, 799 1037
00: 19: 45, 440 --> 00: 19: 49, 280
judge using structured output and we'll 1038
00: 19: 47, 789 --> 00: 19: 49, 280 1039
00: 19: 47, 799 --> 00: 19: 52, 039
be using structured output to ensure 1040
00: 19: 49, 270 --> 00: 19: 52, 039 1041
00: 19: 49, 280 --> 00: 19: 54, 600
that our Len judge returns two things 1042
00: 19: 52, 029 --> 00: 19: 54, 600 1043
00: 19: 52, 039 --> 00: 19: 57, 919
the first is a Boolean value this 1044
00: 19: 54, 590 --> 00: 19: 57, 919 1045
00: 19: 54, 600 --> 00: 19: 59, 600
Boolean value will be true if the Allen 1046
00: 19: 57, 909 --> 00: 19: 59, 600 1047
00: 19: 57, 919 --> 00: 20: 2, 520
judge decides that the Student Response 1048
00: 19: 59, 590 --> 00: 20: 2, 520 1049
00: 19: 59, 600 --> 00: 20: 4, 320
is mostly or exactly correct compared to 1050
00: 20: 2, 510 --> 00: 20: 4, 320 1051
00: 20: 2, 520 --> 00: 20: 7, 159
the reference output or the output 1052
00: 20: 4, 310 --> 00: 20: 7, 159 1053
00: 20: 4, 320 --> 00: 20: 9, 080
formable in data set and false if it 1054
00: 20: 7, 149 --> 00: 20: 9, 080 1055
00: 20: 7, 159 --> 00: 20: 10, 960
decides that response generated by 1056
00: 20: 9, 070 --> 00: 20: 10, 960 1057
00: 20: 9, 080 --> 00: 20: 13, 039
a customer support agent is not accurate 1058
00: 20: 10, 950 --> 00: 20: 13, 039 1059
00: 20: 10, 960 --> 00: 20: 15, 880
or not correct relative to the output 1060
00: 20: 13, 029 --> 00: 20: 15, 880 1061
00: 20: 13, 039 --> 00: 20: 18, 039
our golden data set and our LM judge 1062
00: 20: 15, 870 --> 00: 20: 18, 039 1063
00: 20: 15, 880 --> 00: 20: 20, 360
will also return another field that's a 1064
00: 20: 18, 029 --> 00: 20: 20, 360 1065
00: 20: 18, 039 --> 00: 20: 22, 400
string the string will just explain the 1066
00: 20: 20, 350 --> 00: 20: 22, 400 1067
00: 20: 20, 360 --> 00: 20: 25, 039
LM judge's reasoning or rationale for 1068
00: 20: 22, 390 --> 00: 20: 25, 039 1069
00: 20: 22, 400 --> 00: 20: 27, 320
why it decided that our customer support 1070
00: 20: 25, 029 --> 00: 20: 27, 320 1071
00: 20: 25, 039 --> 00: 20: 30, 080
agent answer was correct or 1072
00: 20: 27, 310 --> 00: 20: 30, 080 1073
00: 20: 27, 320 --> 00: 20: 31, 960
not and so we're just going to be we're 1074
00: 20: 30, 070 --> 00: 20: 31, 960 1075
00: 20: 30, 080 --> 00: 20: 34, 440
just going to be returning that Boolean 1076
00: 20: 31, 950 --> 00: 20: 34, 440 1077
00: 20: 31, 960 --> 00: 20: 36, 240
is correct value to lsmith and we'll be 1078
00: 20: 34, 430 --> 00: 20: 36, 240 1079
00: 20: 34, 440 --> 00: 20: 37, 400
able to see it on the UI after we kick 1080
00: 20: 36, 230 --> 00: 20: 37, 400 1081
00: 20: 36, 240 --> 00: 20: 39, 440
off this 1082
00: 20: 37, 390 --> 00: 20: 39, 440 1083
00: 20: 37, 400 --> 00: 20: 41, 280
experiment so the last step is to 1084
00: 20: 39, 430 --> 00: 20: 41, 280 1085
00: 20: 39, 440 --> 00: 20: 43, 679 run the evaluation and we'll 1086
00: 20: 41, 270 --> 00: 20: 43, 679 1087
00: 20: 41, 280 --> 00: 20: 45, 120
run the evaluation using langens Smith's 1088
00: 20: 43, 669 --> 00: 20: 45, 120 1089
00: 20: 43, 679 --> 00: 20: 47, 240 evaluate 1090
00: 20: 45, 110 --> 00: 20: 47, 240 1091
00: 20: 45, 120 --> 00: 20: 49, 000
function and inside of this evalate 1092
00: 20: 47, 230 --> 00: 20: 49, 000 1093
00: 20: 47, 240 --> 00: 20: 52, 080
function all we need to do is specify 1094
00: 20: 48, 990 --> 00: 20: 52, 080 1095
00: 20: 49, 000 --> 00: 20: 53, 840
our Target function oneor graph which 1096
00: 20: 52, 070 --> 00: 20: 53, 840 1097
00: 20: 52, 080 --> 00: 20: 56, 159
houses our application logic or our 1098
00: 20: 53, 830 --> 00: 20: 56, 159 1099
00: 20: 53, 840 --> 00: 20: 58, 919
customer support agent we'll need to 1100
00: 20: 56, 149 --> 00: 20: 58, 919 1101
00: 20: 56, 159 --> 00: 21: 0, 600
specify the name of our golden data set 1102
00: 20: 58, 909 --> 00: 21: 0, 600 1103
00: 20: 58, 919 --> 00: 21: 2, 640
a list of the evaluators that will be 1104
00: 21: 0, 590 --> 00: 21: 2, 640 1105
00: 21: 0, 600 --> 00: 21: 5, 120
used to score the new outputs generated 1106
00: 21: 2, 630 --> 00: 21: 5, 120 1107
00: 21: 2, 640 --> 00: 21: 7, 159
by our customer support agent in this 1108
00: 21: 5, 110 --> 00: 21: 7, 159 1109
00: 21: 5, 120 --> 00: 21: 9, 120
case it's just the final answer correct 1110
00: 21: 7, 149 --> 00: 21: 9, 120 1111
00: 21: 7, 159 --> 00: 21: 12, 080
evaluator we defined up 1112
00: 21: 9, 110 --> 00: 21: 12, 080 1113
00: 21: 9, 120 --> 00: 21: 14, 559
here and the name of the experiment and 1114
00: 21: 12, 070 --> 00: 21: 14, 559 1115
00: 21: 12, 080 --> 00: 21: 15, 520
this will be present on linki UI as well 1116
00: 21: 14, 549 --> 00: 21: 15, 520 1117
00: 21: 14, 559 --> 00: 21: 18, 200
which is where we're going to 1118
00: 21: 15, 510 --> 00: 21: 18, 200 1119
00: 21: 15, 520 --> 00: 21: 20, 200
jump to now all we're in Langs 1120
00: 21: 18, 190 --> 00: 21: 20, 200 1121
00: 21: 18, 200 --> 00: 21: 22, 000
Smith's UI the first thing we can note 1122
00: 21: 20, 190 --> 00: 21: 22, 000 1123
00: 21: 20, 200 --> 00: 21: 24, 559
is that our golden data set was 1124
00: 21: 21, 990 --> 00: 21: 24, 559 1125
00: 21: 22, 000 --> 00: 21: 26, 320
successfully created so if I click into 1126
00: 21: 24, 549 --> 00: 21: 26, 320 1127
00: 21: 24, 559 --> 00: 21: 28, 919
this data set in lsmith and toggle over 1128
00: 21: 26, 310 --> 00: 21: 28, 919 1129
00: 21: 26, 320 --> 00: 21: 30, 960
to examples we can see that the and the 1130
00: 21: 28, 909 --> 00: 21: 30, 960 1131
00: 21: 28, 919 --> 00: 21: 33, 840
outputs that we defined in code or 1132
00: 21: 30, 950 --> 00: 21: 33, 840 1133
00: 21: 30, 960 --> 00: 21: 36, 679
successfully send over to Langs Smith so 1134
00: 21: 33, 830 --> 00: 21: 36, 679 1135
00: 21: 33, 840 --> 00: 21: 39, 320
let's click into an example inut an 1136
00: 21: 36, 669 --> 00: 21: 39, 320 1137
00: 21: 36, 679 --> 00: 21: 41, 400
output so the input is just one of the 1138
00: 21: 39, 310 --> 00: 21: 41, 400 1139
00: 21: 39, 320 --> 00: 21: 42, 960
questions we defined in code how many 1140
00: 21: 41, 390 --> 00: 21: 42, 960 1141
00: 21: 41, 400 --> 00: 21: 45, 080
songs you have by James 1142
00: 21: 42, 950 --> 00: 21: 45, 080 1143
00: 21: 42, 960 --> 00: 21: 47, 080
Brown and the output is that high 1144
00: 21: 45, 070 --> 00: 21: 47, 080 1145
00: 21: 45, 080 --> 00: 21: 49, 640
quality accurate answer we would 1146
00: 21: 47, 070 --> 00: 21: 49, 640 1147
00: 21: 47, 080 --> 00: 21: 51, 520
our agent to return when given this 1148
00: 21: 49, 630 --> 00: 21: 51, 520 1149
00: 21: 49, 640 --> 00: 21: 54, 520
question and so here we have the 1150
00: 21: 51, 510 --> 00: 21: 54, 520 1151
00: 21: 51, 520 --> 00: 21: 57, 520
response we have 20 songs by James Brown 1152
00: 21: 54, 510 --> 00: 21: 57, 520 1153
00: 21: 54, 520 --> 00: 21: 59, 000
so great our golden data set was created 1154
00: 21: 57, 510 --> 00: 21: 59, 000 1155
00: 21: 57, 520 --> 00: 22: 0, 320
and now let's go take a look at the 1156
00: 21: 58, 990 --> 00: 22: 0, 320 1157
00: 21: 59, 000 --> 00: 22: 3, 840
experiment that we 1158
00: 22: 0, 310 --> 00: 22: 3, 840 1159
00: 22: 0, 320 --> 00: 22: 6, 320
ran so if I click in I can view this 1160
00: 22: 3, 830 --> 00: 22: 6, 320 1161
00: 22: 3, 840 --> 00: 22: 8, 159
experiment in pretty rler detail I'll 1162
00: 22: 6, 310 --> 00: 22: 8, 159 1163
00: 22: 6, 320 --> 00: 22: 11, 000
see the inputs and the outputs for my 1164
00: 22: 8, 149 --> 00: 22: 11, 000 1165
00: 22: 8, 159 --> 00: 22: 13, 200
golden data set I'll see the output that 1166
00: 22: 10, 990 --> 00: 22: 13, 200 1167
00: 22: 11, 000 --> 00: 22: 15, 120
was generated by my target function or 1168
00: 22: 13, 190 --> 00: 22: 15, 120 1169
00: 22: 13, 200 --> 00: 22: 17, 440
by my customer sport agent when it 1170
00: 22: 15, 110 --> 00: 22: 17, 440 1171
00: 22: 15, 120 --> 00: 22: 21, 440
received the input for my golden data 1172
00: 22: 17, 430 --> 00: 22: 21, 440 1173
00: 22: 17, 440 --> 00: 22: 23, 320
set and I'll see the score that my LM 1174
00: 22: 21, 430 --> 00: 22: 23, 320 1175
00: 22: 21, 440 --> 00: 22: 26, 480
judge gave this new output by my 1176
00: 22: 23, 310 --> 00: 22: 26, 480 1177
00: 22: 23, 320 --> 00: 22: 28, 240
customer support agent for accuracy now 1178
00: 22: 26, 470 --> 00: 22: 28, 240 1179
00: 22: 26, 480 --> 00: 22: 30, 559
if you remember in code we were having 1180
00: 22: 28, 230 --> 00: 22: 30, 559 1181
00: 22: 28, 240 --> 00: 22: 32, 679
our Allen judge return a bullying value 1182
00: 22: 30, 549 --> 00: 22: 32, 679 1183
00: 22: 30, 559 --> 00: 22: 35, 159
true or false for whether this new 1184
00: 22: 32, 669 --> 00: 22: 35, 159 1185
00: 22: 32, 679 --> 00: 22: 37, 799
output was accurate or 1186
00: 22: 35, 149 --> 00: 22: 37, 799 1187
00: 22: 35, 159 --> 00: 22: 39, 840
inaccurate so here the true or false 1188
00: 22: 37, 789 --> 00: 22: 39, 840 1189
00: 22: 37, 799 --> 00: 22: 42, 840
bulling value is just showing up as Z or 1190
00: 22: 39, 830 --> 00: 22: 42, 840 1191
00: 22: 39, 840 --> 00: 22: 45, 480
one is true zero is 1192
00: 22: 42, 830 --> 00: 22: 45, 480 1193
00: 22: 42, 840 --> 00: 22: 47, 279
false so here we can see that when our 1194
00: 22: 45, 470 --> 00: 22: 47, 279 1195
00: 22: 45, 480 --> 00: 22: 49, 320
customer support agent was given this 1196
00: 22: 47, 269 --> 00: 22: 49, 320 1197
00: 22: 47, 279 --> 00: 22: 51, 520
input from Golden data set in the Target 1198
00: 22: 49, 310 --> 00: 22: 51, 520 1199
00: 22: 49, 320 --> 00: 22: 53, 840
function it did a really good job at 1200
00: 22: 51, 510 --> 00: 22: 53, 840 1201
00: 22: 51, 520 --> 00: 22: 57, 400
producing accurate response and thus our 1202
00: 22: 53, 830 --> 00: 22: 57, 400 1203
00: 22: 53, 840 --> 00: 23: 0, 880
Len judge gave it one or true for 1204
00: 22: 57, 390 --> 00: 23: 0, 880 1205
00: 22: 57, 400 --> 00: 23: 2, 919
being correct we can see down here our 1206
00: 23: 0, 870 --> 00: 23: 2, 919 1207
00: 23: 0, 880 --> 00: 23: 5, 760
customer support agent struggled when 1208
00: 23: 2, 909 --> 00: 23: 5, 760 1209
00: 23: 2, 919 --> 00: 23: 8, 320
given this question about who Rec 1210
00: 23: 5, 750 --> 00: 23: 8, 320 1211
00: 23: 5, 760 --> 00: 23: 11, 480
who recorded wish you were here again 1212
00: 23: 8, 310 --> 00: 23: 11, 480 1213
00: 23: 8, 320 --> 00: 23: 14, 159
and thus our judge returned false or 1214
00: 23: 11, 470 --> 00: 23: 14, 159 1215
00: 23: 11, 480 --> 00: 23: 15, 279
that it its response was not accurate we 1216
00: 23: 14, 149 --> 00: 23: 15, 279 1217
00: 23: 14, 159 --> 00: 23: 17, 600
can scroll through and see what our 1218
00: 23: 15, 269 --> 00: 23: 17, 600 1219
00: 23: 15, 279 --> 00: 23: 19, 880
Allen judge scored everywhere they 1220
00: 23: 17, 590 --> 00: 23: 19, 880 1221
00: 23: 17, 600 --> 00: 23: 22, 480
output here as well one thing that's 1222
00: 23: 19, 870 --> 00: 23: 22, 480 1223
00: 23: 19, 880 --> 00: 23: 24, 440
really nice about this experiment view 1224
00: 23: 22, 470 --> 00: 23: 24, 440 1225
00: 23: 22, 480 --> 00: 23: 26, 880
is we can click in and look at 1226
00: 23: 24, 430 --> 00: 23: 26, 880 1227
00: 23: 24, 440 --> 00: 23: 29, 039
an individual evaluator run so when I 1228
00: 23: 26, 870 --> 00: 23: 29, 039 1229
00: 23: 26, 880 --> 00: 23: 30, 480
click into an evaluator run I can see 1230
00: 23: 29, 029 --> 00: 23: 30, 480 1231
00: 23: 29, 039 --> 00: 23: 32, 799
what our valuator looks under the 1232
00: 23: 30, 470 --> 00: 23: 32, 799 1233
00: 23: 30, 480 --> 00: 23: 35, 679
hood so just how was defined in 1234
00: 23: 32, 789 --> 00: 23: 35, 679 1235
00: 23: 32, 799 --> 00: 23: 38, 279
code we can see that we Ed an LM judge 1236
00: 23: 35, 669 --> 00: 23: 38, 279 1237
00: 23: 35, 679 --> 00: 23: 39, 960
in this case chap ke4 mini with a 1238
00: 23: 38, 269 --> 00: 23: 39, 960 1239
00: 23: 38, 279 --> 00: 23: 42, 039
special system prompt and the system 1240
00: 23: 39, 950 --> 00: 23: 42, 039 1241
00: 23: 39, 960 --> 00: 23: 43, 480
prompt instructs it to act as a teacher 1242
00: 23: 42, 029 --> 00: 23: 43, 480 1243
00: 23: 42, 039 --> 00: 23: 45, 799
grading a 1244
00: 23: 43, 470 --> 00: 23: 45, 799 1245
00: 23: 43, 480 --> 00: 23: 48, 120
quiz and we can see that we give this 1246
00: 23: 45, 789 --> 00: 23: 48, 120 1247
00: 23: 45, 799 --> 00: 23: 49, 640
Len judge a human message that has 1248
00: 23: 48, 110 --> 00: 23: 49, 640 1249
00: 23: 48, 120 --> 00: 23: 51, 840
context on the input from our golden 1250
00: 23: 49, 630 --> 00: 23: 51, 840 1251
00: 23: 49, 640 --> 00: 23: 53, 720
data set the output from our golden data 1252
00: 23: 51, 830 --> 00: 23: 53, 720 1253
00: 23: 51, 840 --> 00: 23: 57, 279
set which is referenced as a ground 1254
00: 23: 53, 710 --> 00: 23: 57, 279 1255
00: 23: 53, 720 --> 00: 23: 58, 919
truth response and a student response 1256
00: 23: 57, 269 --> 00: 23: 58, 919 1257
00: 23: 57, 279 --> 00: 24: 0, 840
which is just the answer that our 1258
00: 23: 58, 909 --> 00: 24: 0, 840 1259
00: 23: 58, 919 --> 00: 24: 3, 159
customer support agent generated in the 1260
00: 24: 0, 830 --> 00: 24: 3, 159 1261
00: 24: 0, 840 --> 00: 24: 6, 200
taret function and then at the very 1262
00: 24: 3, 149 --> 00: 24: 6, 200 1263
00: 24: 3, 159 --> 00: 24: 7, 960
bottom we'll see that response from our 1264
00: 24: 6, 190 --> 00: 24: 7, 960 1265
00: 24: 6, 200 --> 00: 24: 10, 919
L judge which includes both the 1266
00: 24: 7, 950 --> 00: 24: 10, 919 1267
00: 24: 7, 960 --> 00: 24: 15, 080
reasoning or the rationale for why it 1268
00: 24: 10, 909 --> 00: 24: 15, 080 1269
00: 24: 10, 919 --> 00: 24: 17, 600
either judg our response as accurate or 1270
00: 24: 15, 070 --> 00: 24: 17, 600 1271
00: 24: 15, 080 --> 00: 24: 19, 960
inaccurate in the Boolean value for 1272
00: 24: 17, 590 --> 00: 24: 19, 960 1273
00: 24: 17, 600 --> 00: 24: 23, 960
whether it decided our output was 1274
00: 24: 19, 950 --> 00: 24: 23, 960 1275
00: 24: 19, 960 --> 00: 24: 26, 159
was correct or not great so talking 1276
00: 24: 23, 950 --> 00: 24: 26, 159 1277
00: 24: 23, 960 --> 00: 24: 27, 880
back over to the data set one other 1278
00: 24: 26, 149 --> 00: 24: 27, 880 1279
00: 24: 26, 159 --> 00: 24: 29, 919
thing that I think is super helpful 1280
00: 24: 27, 870 --> 00: 24: 29, 919 1281
00: 24: 27, 880 --> 00: 24: 33, 279
is viewing our experiment at a 1282
00: 24: 29, 909 --> 00: 24: 33, 279 1283
00: 24: 29, 919 --> 00: 24: 35, 320
high level so here I can see that across 1284
00: 24: 33, 269 --> 00: 24: 35, 320 1285
00: 24: 33, 279 --> 00: 24: 38, 760
all my runs the average correctness 1286
00: 24: 35, 310 --> 00: 24: 38, 760 1287
00: 24: 35, 320 --> 00: 24: 41, 960
score was 6 so ideally we'd this 1288
00: 24: 38, 750 --> 00: 24: 41, 960 1289
00: 24: 38, 760 --> 00: 24: 44, 559
this to be one meaning all of our all of 1290
00: 24: 41, 950 --> 00: 24: 44, 559 1291
00: 24: 41, 960 --> 00: 24: 47, 760
our runs received correctness equal 1292
00: 24: 44, 549 --> 00: 24: 47, 760 1293
00: 24: 44, 559 --> 00: 24: 49, 320
to True by our all judge we can see 1294
00: 24: 47, 750 --> 00: 24: 49, 320 1295
00: 24: 47, 760 --> 00: 24: 51, 919
that's not the case and thus we have a 1296
00: 24: 49, 310 --> 00: 24: 51, 919 1297
00: 24: 49, 320 --> 00: 24: 53, 399
good bit of work to do before we release 1298
00: 24: 51, 909 --> 00: 24: 53, 399 1299
00: 24: 51, 919 --> 00: 24: 54, 120
this customer support agent to all of 1300
00: 24: 53, 389 --> 00: 24: 54, 120 1301
00: 24: 53, 399 --> 00: 24: 56, 200
our 1302
00: 24: 54, 110 --> 00: 24: 56, 200 1303
00: 24: 54, 120 --> 00: 24: 58, 520
users and light spits will also provide 1304
00: 24: 56, 190 --> 00: 24: 58, 520 1305
00: 24: 56, 200 --> 00: 25: 1, 799
us some pretty nice information on the p 1306
00: 24: 58, 510 --> 00: 25: 1, 799 1307
00: 24: 58, 520 --> 00: 25: 4, 960
latency P99 latency in aor rate cross 1308
00: 25: 1, 789 --> 00: 25: 4, 960 1309
00: 25: 1, 799 --> 00: 25: 7, 000
the runs in the experiment let's move 1310
00: 25: 4, 950 --> 00: 25: 7, 000 1311
00: 25: 4, 960 --> 00: 25: 9, 159
on to our second evaluation strategy 1312
00: 25: 6, 990 --> 00: 25: 9, 159 1313
00: 25: 7, 000 --> 00: 25: 11, 240
single step in the single step 1314
00: 25: 9, 149 --> 00: 25: 11, 240 1315
00: 25: 9, 159 --> 00: 25: 14, 360
evaluation we're going to be assessing 1316
00: 25: 11, 230 --> 00: 25: 14, 360 1317
00: 25: 11, 240 --> 00: 25: 17, 600
how well my supervisor node or my intent 1318
00: 25: 14, 350 --> 00: 25: 17, 600 1319
00: 25: 14, 360 --> 00: 25: 20, 520
classification step performs when given 1320
00: 25: 17, 590 --> 00: 25: 20, 520 1321
00: 25: 17, 600 --> 00: 25: 22, 440
a question from a customer ideally when 1322
00: 25: 20, 510 --> 00: 25: 22, 440 1323
00: 25: 20, 520 --> 00: 25: 24, 360
we receive a question from a customer 1324
00: 25: 22, 430 --> 00: 25: 24, 360 1325
00: 25: 22, 440 --> 00: 25: 26, 039
we'd our supervisor node to always 1326
00: 25: 24, 350 --> 00: 25: 26, 039 1327
00: 25: 24, 360 --> 00: 25: 28, 320
correctly route it to either the 1328
00: 25: 26, 029 --> 00: 25: 28, 320 1329
00: 25: 26, 039 --> 00: 25: 30, 399
question answering subgraph or the 1330
00: 25: 28, 310 --> 00: 25: 30, 399 1331
00: 25: 28, 320 --> 00: 25: 31, 640
process refund subgraph based on the 1332
00: 25: 30, 389 --> 00: 25: 31, 640 1333
00: 25: 30, 399 --> 00: 25: 34, 240
content of the 1334
00: 25: 31, 630 --> 00: 25: 34, 240 1335
00: 25: 31, 640 --> 00: 25: 36, 720
question to run this evaluation the 1336
00: 25: 34, 230 --> 00: 25: 36, 720 1337
00: 25: 34, 240 --> 00: 25: 39, 360
first step is going to be again Define a 1338
00: 25: 36, 710 --> 00: 25: 39, 360 1339
00: 25: 36, 720 --> 00: 25: 41, 720
golden data set i'm defining this golden 1340
00: 25: 39, 350 --> 00: 25: 41, 720 1341
00: 25: 39, 360 --> 00: 25: 44, 480
data set manually in code and I have 1342
00: 25: 41, 710 --> 00: 25: 44, 480 1343
00: 25: 41, 720 --> 00: 25: 46, 919
five inputs and outputs already defined 1344
00: 25: 44, 470 --> 00: 25: 46, 919 1345
00: 25: 44, 480 --> 00: 25: 49, 159
here the inputs in my golden data set 1346
00: 25: 46, 909 --> 00: 25: 49, 159 1347
00: 25: 46, 919 --> 00: 25: 51, 360
are just going to be a list of 1348
00: 25: 49, 149 --> 00: 25: 51, 360 1349
00: 25: 49, 159 --> 00: 25: 52, 960
messages sometimes this list of messages 1350
00: 25: 51, 350 --> 00: 25: 52, 960 1351
00: 25: 51, 360 --> 00: 25: 55, 559
is just going to have a single message 1352
00: 25: 52, 950 --> 00: 25: 55, 559 1353
00: 25: 52, 960 --> 00: 25: 57, 919
from a customer this message from a 1354
00: 25: 55, 549 --> 00: 25: 57, 919 1355
00: 25: 55, 559 --> 00: 25: 58, 840
customer will have a question so in this 1356
00: 25: 57, 909 --> 00: 25: 58, 840 1357
00: 25: 57, 919 --> 00: 25: 59, 840
example 1358
00: 25: 58, 830 --> 00: 25: 59, 840 1359
00: 25: 58, 840 --> 00: 26: 1, 760
in the 1360
00: 25: 59, 830 --> 00: 26: 1, 760 1361
00: 25: 59, 840 --> 00: 26: 3, 600
input it's just going to be a question 1362
00: 26: 1, 750 --> 00: 26: 3, 600 1363
00: 26: 1, 760 --> 00: 26: 4, 880
from a customer that's asking hey I 1364
00: 26: 3, 590 --> 00: 26: 4, 880 1365
00: 26: 3, 600 --> 00: 26: 8, 120
bought some tracks recently and I don't 1366
00: 26: 4, 870 --> 00: 26: 8, 120 1367
00: 26: 4, 880 --> 00: 26: 10, 080 them the outputs in my golden data 1368
00: 26: 8, 110 --> 00: 26: 10, 080 1369
00: 26: 8, 120 --> 00: 26: 12, 320
set are just going to be the names of 1370
00: 26: 10, 070 --> 00: 26: 12, 320 1371
00: 26: 10, 080 --> 00: 26: 14, 279
the subgraphs or the agents that we 1372
00: 26: 12, 310 --> 00: 26: 14, 279 1373
00: 26: 12, 320 --> 00: 26: 17, 120
would our intent classifier or 1374
00: 26: 14, 269 --> 00: 26: 17, 120 1375
00: 26: 14, 279 --> 00: 26: 19, 360
supervisor node to route to when it 1376
00: 26: 17, 110 --> 00: 26: 19, 360 1377
00: 26: 17, 120 --> 00: 26: 21, 679
receives this list of messages as 1378
00: 26: 19, 350 --> 00: 26: 21, 679 1379
00: 26: 19, 360 --> 00: 26: 24, 279
context so again sometimes the infs are 1380
00: 26: 21, 669 --> 00: 26: 24, 279 1381
00: 26: 21, 679 --> 00: 26: 26, 880
just going to be a single ask 1382
00: 26: 24, 269 --> 00: 26: 26, 880 1383
00: 26: 24, 279 --> 00: 26: 30, 159
from a customer and sometimes it's going 1384
00: 26: 26, 870 --> 00: 26: 30, 159 1385
00: 26: 26, 880 --> 00: 26: 32, 760
to be a list of mult full messages so in 1386
00: 26: 30, 149 --> 00: 26: 32, 760 1387
00: 26: 30, 159 --> 00: 26: 34, 880
this example here the most recent 1388
00: 26: 32, 750 --> 00: 26: 34, 880 1389
00: 26: 32, 760 --> 00: 26: 37, 159
message is still going to be an ask from 1390
00: 26: 34, 870 --> 00: 26: 37, 159 1391
00: 26: 34, 880 --> 00: 26: 39, 200
a customer so here the customer is 1392
00: 26: 37, 149 --> 00: 26: 39, 200 1393
00: 26: 37, 159 --> 00: 26: 41, 080
asking did Prince release any albums in 1394
00: 26: 39, 190 --> 00: 26: 41, 080 1395
00: 26: 39, 200 --> 00: 26: 44, 320
two in 1396
00: 26: 41, 070 --> 00: 26: 44, 320 1397
00: 26: 41, 080 --> 00: 26: 47, 120
2000 but the list of messages also has 1398
00: 26: 44, 310 --> 00: 26: 47, 120 1399
00: 26: 44, 320 --> 00: 26: 48, 559
two previous two previous messages that 1400
00: 26: 47, 110 --> 00: 26: 48, 559 1401
00: 26: 47, 120 --> 00: 26: 51, 120
were exchanged back and forth between 1402
00: 26: 48, 549 --> 00: 26: 51, 120 1403
00: 26: 48, 559 --> 00: 26: 52, 960
the customer and the customer for agent 1404
00: 26: 51, 110 --> 00: 26: 52, 960 1405
00: 26: 51, 120 --> 00: 26: 55, 520
so the first message is the customer 1406
00: 26: 52, 950 --> 00: 26: 55, 520 1407
00: 26: 52, 960 --> 00: 26: 58, 919
asking I want to refund on purchase 1408
00: 26: 55, 510 --> 00: 26: 58, 919 1409
00: 26: 55, 520 --> 00: 27: 1, 880
237 and the second message is the 1410
00: 26: 58, 909 --> 00: 27: 1, 880 1411
00: 26: 58, 919 --> 00: 27: 4, 200
customer support agents reply which said 1412
00: 27: 1, 870 --> 00: 27: 4, 200 1413
00: 27: 1, 880 --> 00: 27: 6, 799
I've refunded you for that purchase it 1414
00: 27: 4, 190 --> 00: 27: 6, 799 1415
00: 27: 4, 200 --> 00: 27: 7, 799
was a total of $1. 98 how else can I help 1416
00: 27: 6, 789 --> 00: 27: 7, 799 1417
00: 27: 6, 799 --> 00: 27: 12, 039
you 1418
00: 27: 7, 789 --> 00: 27: 12, 039 1419
00: 27: 7, 799 --> 00: 27: 14, 760
today and again the output is going to 1420
00: 27: 12, 029 --> 00: 27: 14, 760 1421
00: 27: 12, 039 --> 00: 27: 16, 600
be the name of the subgraph or the agent 1422
00: 27: 14, 750 --> 00: 27: 16, 600 1423
00: 27: 14, 760 --> 00: 27: 19, 200
that we'd our impant classifier or 1424
00: 27: 16, 590 --> 00: 27: 19, 200 1425
00: 27: 16, 600 --> 00: 27: 22, 799
supervisor node to route to when it 1426
00: 27: 19, 190 --> 00: 27: 22, 799 1427
00: 27: 19, 200 --> 00: 27: 25, 039
receives this ask in these two previous 1428
00: 27: 22, 789 --> 00: 27: 25, 039 1429
00: 27: 22, 799 --> 00: 27: 26, 640
messages as context for what already 1430
00: 27: 25, 029 --> 00: 27: 26, 640 1431
00: 27: 25, 039 --> 00: 27: 28, 880
took place in the 1432
00: 27: 26, 630 --> 00: 27: 28, 880 1433
00: 27: 26, 640 --> 00: 27: 31, 000
conversation so we're going to create a 1434
00: 27: 28, 870 --> 00: 27: 31, 000 1435
00: 27: 28, 880 --> 00: 27: 33, 120
data set with these inputs and outputs 1436
00: 27: 30, 990 --> 00: 27: 33, 120 1437
00: 27: 31, 000 --> 00: 27: 35, 520
and send them off to 1438
00: 27: 33, 110 --> 00: 27: 35, 520 1439
00: 27: 33, 120 --> 00: 27: 37, 520
lsmith the second step to running this 1440
00: 27: 35, 510 --> 00: 27: 37, 520 1441
00: 27: 35, 520 --> 00: 27: 39, 159
evaluation is going to be defining the 1442
00: 27: 37, 510 --> 00: 27: 39, 159 1443
00: 27: 37, 520 --> 00: 27: 41, 760
application logic we want 1444
00: 27: 39, 149 --> 00: 27: 41, 760 1445
00: 27: 39, 159 --> 00: 27: 43, 960
evaluated and so for this evaluation 1446
00: 27: 41, 750 --> 00: 27: 43, 960 1447
00: 27: 41, 760 --> 00: 27: 47, 039
because I'm not I'm 1448
00: 27: 43, 950 --> 00: 27: 47, 039 1449
00: 27: 43, 960 --> 00: 27: 49, 320
not evaluating my entire agent I'm just 1450
00: 27: 47, 029 --> 00: 27: 49, 320 1451
00: 27: 47, 039 --> 00: 27: 52, 440
evaluating the performance of a specific 1452
00: 27: 49, 310 --> 00: 27: 52, 440 1453
00: 27: 49, 320 --> 00: 27: 54, 720
step I don't need to run the inputs for 1454
00: 27: 52, 430 --> 00: 27: 54, 720 1455
00: 27: 52, 440 --> 00: 27: 56, 720
my golden data set which get P to my 1456
00: 27: 54, 710 --> 00: 27: 56, 720 1457
00: 27: 54, 720 --> 00: 27: 58, 559
target function When We Run The 1458
00: 27: 56, 710 --> 00: 27: 58, 559 1459
00: 27: 56, 720 --> 00: 28: 0, 080
Experiment I don't need to run these 1460
00: 27: 58, 549 --> 00: 28: 0, 080 1461
00: 27: 58, 559 --> 00: 28: 3, 159
inputs from my golden data set on the 1462
00: 28: 0, 070 --> 00: 28: 3, 159 1463
00: 28: 0, 080 --> 00: 28: 5, 200
entire graph I can take the 1464
00: 28: 3, 149 --> 00: 28: 5, 200 1465
00: 28: 3, 159 --> 00: 28: 6, 840
inputs from my golden data set which 1466
00: 28: 5, 190 --> 00: 28: 6, 840 1467
00: 28: 5, 200 --> 00: 28: 10, 159
gets sent to my target function when the 1468
00: 28: 6, 830 --> 00: 28: 10, 159 1469
00: 28: 6, 840 --> 00: 28: 11, 440
experiment runs to just the intent 1470
00: 28: 10, 149 --> 00: 28: 11, 440 1471
00: 28: 10, 159 --> 00: 28: 14, 159
classifier 1472
00: 28: 11, 430 --> 00: 28: 14, 159 1473
00: 28: 11, 440 --> 00: 28: 16, 679
node and when I get a response back from 1474
00: 28: 14, 149 --> 00: 28: 16, 679 1475
00: 28: 14, 159 --> 00: 28: 20, 039
the intent classifier node I can use the 1476
00: 28: 16, 669 --> 00: 28: 20, 039 1477
00: 28: 16, 679 --> 00: 28: 22, 559
goto property to get back the name of 1478
00: 28: 20, 029 --> 00: 28: 22, 559 1479
00: 28: 20, 039 --> 00: 28: 25, 360
the subgraph or the agent that it wants 1480
00: 28: 22, 549 --> 00: 28: 25, 360 1481
00: 28: 22, 559 --> 00: 28: 26, 679
to Route the query to next so that's 1482
00: 28: 25, 350 --> 00: 28: 26, 679 1483
00: 28: 25, 360 --> 00: 28: 29, 159
what my target function is 1484
00: 28: 26, 669 --> 00: 28: 29, 159 1485
00: 28: 26, 679 --> 00: 28: 31, 360
going to do in this in this single 1486
00: 28: 29, 149 --> 00: 28: 31, 360 1487
00: 28: 29, 159 --> 00: 28: 34, 279
step 1488
00: 28: 31, 350 --> 00: 28: 34, 279 1489
00: 28: 31, 360 --> 00: 28: 36, 880
evaluation next I'm going to Define my 1490
00: 28: 34, 269 --> 00: 28: 36, 880 1491
00: 28: 34, 279 --> 00: 28: 39, 919
evaluator so my evaluator is going to 1492
00: 28: 36, 870 --> 00: 28: 39, 919 1493
00: 28: 36, 880 --> 00: 28: 42, 320
receive the outputs or whatever my 1494
00: 28: 39, 909 --> 00: 28: 42, 320 1495
00: 28: 39, 919 --> 00: 28: 44, 640
target function returns when given 1496
00: 28: 42, 310 --> 00: 28: 44, 640 1497
00: 28: 42, 320 --> 00: 28: 46, 240
the inputs from the gold data set and 1498
00: 28: 44, 630 --> 00: 28: 46, 240 1499
00: 28: 44, 640 --> 00: 28: 48, 600
the reference outputs which are the 1500
00: 28: 46, 230 --> 00: 28: 48, 600 1501
00: 28: 46, 240 --> 00: 28: 50, 039
outputs from our golden data set and my 1502
00: 28: 48, 590 --> 00: 28: 50, 039 1503
00: 28: 48, 600 --> 00: 28: 52, 399
evaluator here is much simpler than the 1504
00: 28: 50, 029 --> 00: 28: 52, 399 1505
00: 28: 50, 039 --> 00: 28: 56, 640
one in the final response evaluator all 1506
00: 28: 52, 389 --> 00: 28: 56, 640 1507
00: 28: 52, 399 --> 00: 28: 58, 720
it does is a is a simple check is the is 1508
00: 28: 56, 630 --> 00: 28: 58, 720 1509
00: 28: 56, 640 --> 00: 29: 1, 080
the subgraph that my for support agent 1510
00: 28: 58, 710 --> 00: 29: 1, 080 1511
00: 28: 58, 720 --> 00: 29: 3, 760
want and to route to when it received 1512
00: 29: 1, 070 --> 00: 29: 3, 760 1513
00: 29: 1, 080 --> 00: 29: 5, 440
that list of messages equivalent to 1514
00: 29: 3, 750 --> 00: 29: 5, 440 1515
00: 29: 3, 760 --> 00: 29: 7, 279
the name of the subgraph or the 1516
00: 29: 5, 430 --> 00: 29: 7, 279 1517
00: 29: 5, 440 --> 00: 29: 9, 600
agent that we have in our golden data 1518
00: 29: 7, 269 --> 00: 29: 9, 600 1519
00: 29: 7, 279 --> 00: 29: 11, 960
set we're making this check because the 1520
00: 29: 9, 590 --> 00: 29: 11, 960 1521
00: 29: 9, 600 --> 00: 29: 15, 120
name of the subgraph or the agent in our 1522
00: 29: 11, 950 --> 00: 29: 15, 120 1523
00: 29: 11, 960 --> 00: 29: 16, 799
golden data set is the correct is the 1524
00: 29: 15, 110 --> 00: 29: 16, 799 1525
00: 29: 15, 120 --> 00: 29: 18, 559
correct one so we want to 1526
00: 29: 16, 789 --> 00: 29: 18, 559 1527
00: 29: 16, 799 --> 00: 29: 20, 440
gauge that our that our agent picked the 1528
00: 29: 18, 549 --> 00: 29: 20, 440 1529
00: 29: 18, 559 --> 00: 29: 23, 880 subgraph to route 1530
00: 29: 20, 430 --> 00: 29: 23, 880 1531
00: 29: 20, 440 --> 00: 29: 25, 600
to Great so now we to find all of these 1532
00: 29: 23, 870 --> 00: 29: 25, 600 1533
00: 29: 23, 880 --> 00: 29: 27, 320
the last step is to run the 1534
00: 29: 25, 590 --> 00: 29: 27, 320 1535
00: 29: 25, 600 --> 00: 29: 29, 519
evaluation with the evaluate function 1536
00: 29: 27, 310 --> 00: 29: 29, 519 1537
00: 29: 27, 320 --> 00: 29: 31, 039
again we're going to specify the name of 1538
00: 29: 29, 509 --> 00: 29: 31, 039 1539
00: 29: 29, 519 --> 00: 29: 34, 000
our Target function which houses our 1540
00: 29: 31, 029 --> 00: 29: 34, 000 1541
00: 29: 31, 039 --> 00: 29: 36, 519
application logic again here we're not 1542
00: 29: 33, 990 --> 00: 29: 36, 519 1543
00: 29: 34, 000 --> 00: 29: 37, 880 going to be running the entire 1544
00: 29: 36, 509 --> 00: 29: 37, 880 1545
00: 29: 36, 519 --> 00: 29: 40, 120
graph we're just going to be picking out 1546
00: 29: 37, 870 --> 00: 29: 40, 120 1547
00: 29: 37, 880 --> 00: 29: 42, 000
that intent classifier node giving that 1548
00: 29: 40, 110 --> 00: 29: 42, 000 1549
00: 29: 40, 120 --> 00: 29: 44, 200
the inputs from our golden data 1550
00: 29: 41, 990 --> 00: 29: 44, 200 1551
00: 29: 42, 000 --> 00: 29: 46, 760
set we're going to define the name of 1552
00: 29: 44, 190 --> 00: 29: 46, 760 1553
00: 29: 44, 200 --> 00: 29: 49, 440
our golden data set the list of 1554
00: 29: 46, 750 --> 00: 29: 49, 440 1555
00: 29: 46, 760 --> 00: 29: 53, 120
evaluators and the experiment prefix 1556
00: 29: 49, 430 --> 00: 29: 53, 120 1557
00: 29: 49, 440 --> 00: 29: 53, 120
which will show up in the lens withi 1558
00: 29: 53, 269 --> 00: aN: NaN, NaN 1559
00: 29: 53, 279 --> 00: 29: 57, 480
UI all we're back in the LSI UI 1560
00: 29: 56, 269 --> 00: 29: 57, 480 1561
00: 29: 56, 279 --> 00: 30: 0, 200
the first thing to not is we 1562
00: 29: 57, 470 --> 00: 30: 0, 200 1563
00: 29: 57, 480 --> 00: 30: 2, 840
successfully created our golden data set 1564
00: 30: 0, 190 --> 00: 30: 2, 840 1565
00: 30: 0, 200 --> 00: 30: 5, 679
we can click into any input output pair 1566
00: 30: 2, 830 --> 00: 30: 5, 679 1567
00: 30: 2, 840 --> 00: 30: 8, 320
and see that the input is as expected 1568
00: 30: 5, 669 --> 00: 30: 8, 320 1569
00: 30: 5, 679 --> 00: 30: 10, 480
it's a message or a list of messages 1570
00: 30: 8, 310 --> 00: 30: 10, 480 1571
00: 30: 8, 320 --> 00: 30: 12, 399
that includes questions from customers 1572
00: 30: 10, 470 --> 00: 30: 12, 399 1573
00: 30: 10, 480 --> 00: 30: 14, 320
here we just have one question from a 1574
00: 30: 12, 389 --> 00: 30: 14, 320 1575
00: 30: 12, 399 --> 00: 30: 16, 279
customer and the outputs in the Glen 1576
00: 30: 14, 310 --> 00: 30: 16, 279 1577
00: 30: 14, 320 --> 00: 30: 18, 519
data set instead of it being a high 1578
00: 30: 16, 269 --> 00: 30: 18, 519 1579
00: 30: 16, 279 --> 00: 30: 21, 240
quality accurate output this time it's 1580
00: 30: 18, 509 --> 00: 30: 21, 240 1581
00: 30: 18, 519 --> 00: 30: 23, 480
just the name of the subgraph or agent 1582
00: 30: 21, 230 --> 00: 30: 23, 480 1583
00: 30: 21, 240 --> 00: 30: 26, 240
that we wanted our intent classifier to 1584
00: 30: 23, 470 --> 00: 30: 26, 240 1585
00: 30: 23, 480 --> 00: 30: 29, 000
route to when it receive that message or 1586
00: 30: 26, 230 --> 00: 30: 29, 000 1587
00: 30: 26, 240 --> 00: 30: 31, 080
list of messages as context 1588
00: 30: 28, 990 --> 00: 30: 31, 080 1589
00: 30: 29, 000 --> 00: 30: 32, 640
let's toggle over to experiments and 1590
00: 30: 31, 070 --> 00: 30: 32, 640 1591
00: 30: 31, 080 --> 00: 30: 35, 320
look at the experiment we just ran under 1592
00: 30: 32, 630 --> 00: 30: 35, 320 1593
00: 30: 32, 640 --> 00: 30: 37, 519
the hood so in this view we'll see the 1594
00: 30: 35, 310 --> 00: 30: 37, 519 1595
00: 30: 35, 320 --> 00: 30: 40, 080
inputs and outputs from our golden data 1596
00: 30: 37, 509 --> 00: 30: 40, 080 1597
00: 30: 37, 519 --> 00: 30: 42, 880
set and then we'll see the name of the 1598
00: 30: 40, 070 --> 00: 30: 42, 880 1599
00: 30: 40, 080 --> 00: 30: 44, 880
subgraph or the agent that our intent 1600
00: 30: 42, 870 --> 00: 30: 44, 880 1601
00: 30: 42, 880 --> 00: 30: 47, 799
classifier node inside of the customer 1602
00: 30: 44, 870 --> 00: 30: 47, 799 1603
00: 30: 44, 880 --> 00: 30: 51, 000
sport agent wanted to route to when it 1604
00: 30: 47, 789 --> 00: 30: 51, 000 1605
00: 30: 47, 799 --> 00: 30: 54, 200
received these messages as context from 1606
00: 30: 50, 990 --> 00: 30: 54, 200 1607
00: 30: 51, 000 --> 00: 30: 56, 399
our golden data set so he's done a 1608
00: 30: 54, 190 --> 00: 30: 56, 399 1609
00: 30: 54, 200 --> 00: 30: 58, 760
really great job for each input from 1610
00: 30: 56, 389 --> 00: 30: 58, 760 1611
00: 30: 56, 399 --> 00: 31: 1, 240
the golden data set it routed to the 1612
00: 30: 58, 750 --> 00: 31: 1, 240 1613
00: 30: 58, 760 --> 00: 31: 3, 679
correct subgraph or agent we see across 1614
00: 31: 1, 230 --> 00: 31: 3, 679 1615
00: 31: 1, 240 --> 00: 31: 5, 840
the board that our evaluator gave it the 1616
00: 31: 3, 669 --> 00: 31: 5, 840 1617
00: 31: 3, 679 --> 00: 31: 10, 399 the score of one which means it picks 1618
00: 31: 5, 830 --> 00: 31: 10, 399 1619
00: 31: 5, 840 --> 00: 31: 10, 399
the subgraph to wrap to 1620
00: 31: 10, 830 --> 00: aN: NaN, NaN 1621
00: 31: 10, 840 --> 00: 31: 15, 720
awesome let's dive into our third and 1622
00: 31: 13, 389 --> 00: 31: 15, 720 1623
00: 31: 13, 399 --> 00: 31: 17, 320
final evaluation strategy in this 1624
00: 31: 15, 710 --> 00: 31: 17, 320 1625
00: 31: 15, 720 --> 00: 31: 19, 240
evaluation we'll be assessing whether 1626
00: 31: 17, 310 --> 00: 31: 19, 240 1627
00: 31: 17, 320 --> 00: 31: 21, 960
our customer support agent is following 1628
00: 31: 19, 230 --> 00: 31: 21, 960 1629
00: 31: 19, 240 --> 00: 31: 23, 600
an optimal path or trajectory when it's 1630
00: 31: 21, 950 --> 00: 31: 23, 600 1631
00: 31: 21, 960 --> 00: 31: 25, 480
answering question from a 1632
00: 31: 23, 590 --> 00: 31: 25, 480 1633
00: 31: 23, 600 --> 00: 31: 27, 919
customer the first step we're going to 1634
00: 31: 25, 470 --> 00: 31: 27, 919 1635
00: 31: 25, 480 --> 00: 31: 30, 840
take when conducting this valuation is 1636
00: 31: 27, 909 --> 00: 31: 30, 840 1637
00: 31: 27, 919 --> 00: 31: 33, 159
is creating a golden data set as you can 1638
00: 31: 30, 830 --> 00: 31: 33, 159 1639
00: 31: 30, 840 --> 00: 31: 35, 720
see from my code I'm manually creating a 1640
00: 31: 33, 149 --> 00: 31: 35, 720 1641
00: 31: 33, 159 --> 00: 31: 37, 760
golden data set here and I already have 1642
00: 31: 35, 710 --> 00: 31: 37, 760 1643
00: 31: 35, 720 --> 00: 31: 40, 440
Define five inputs and outputs that this 1644
00: 31: 37, 750 --> 00: 31: 40, 440 1645
00: 31: 37, 760 --> 00: 31: 42, 399
data set will be composed of in each of 1646
00: 31: 40, 430 --> 00: 31: 42, 399 1647
00: 31: 40, 440 --> 00: 31: 44, 320
these input output pairs the input is 1648
00: 31: 42, 389 --> 00: 31: 44, 320 1649
00: 31: 42, 399 --> 00: 31: 46, 159
going to be an example question that a 1650
00: 31: 44, 310 --> 00: 31: 46, 159 1651
00: 31: 44, 320 --> 00: 31: 49, 399
customer would pose our customer support 1652
00: 31: 46, 149 --> 00: 31: 49, 399 1653
00: 31: 46, 159 --> 00: 31: 51, 000
agent and the output is a list of steps 1654
00: 31: 49, 389 --> 00: 31: 51, 000 1655
00: 31: 49, 399 --> 00: 31: 53, 320
that we want our customer support agent 1656
00: 31: 50, 990 --> 00: 31: 53, 320 1657
00: 31: 51, 000 --> 00: 31: 54, 639
to follow in order when answering the 1658
00: 31: 53, 310 --> 00: 31: 54, 639 1659
00: 31: 53, 320 --> 00: 31: 57, 240
question in the 1660
00: 31: 54, 629 --> 00: 31: 57, 240 1661
00: 31: 54, 639 --> 00: 31: 59, 080
input let's use this first input output 1662
00: 31: 57, 230 --> 00: 31: 59, 080 1663
00: 31: 57, 240 --> 00: 32: 1, 000
pair as an example 1664
00: 31: 59, 070 --> 00: 32: 1, 000 1665
00: 31: 59, 080 --> 00: 32: 3, 159
so in this input output pair the input 1666
00: 32: 0, 990 --> 00: 32: 3, 159 1667
00: 32: 1, 000 --> 00: 32: 5, 480
is a question that says how many songs 1668
00: 32: 3, 149 --> 00: 32: 5, 480 1669
00: 32: 3, 159 --> 00: 32: 7, 039
do you have by James Brown and the 1670
00: 32: 5, 470 --> 00: 32: 7, 039 1671
00: 32: 5, 480 --> 00: 32: 8, 519
output is the trajectory that we'd want 1672
00: 32: 7, 029 --> 00: 32: 8, 519 1673
00: 32: 7, 039 --> 00: 32: 10, 480
our customer support agent to follow 1674
00: 32: 8, 509 --> 00: 32: 10, 480 1675
00: 32: 8, 519 --> 00: 32: 11, 880
when it's answering this question so 1676
00: 32: 10, 470 --> 00: 32: 11, 880 1677
00: 32: 10, 480 --> 00: 32: 13, 559
when this customer support agent 1678
00: 32: 11, 870 --> 00: 32: 13, 559 1679
00: 32: 11, 880 --> 00: 32: 15, 799
receives the question how many songs do 1680
00: 32: 13, 549 --> 00: 32: 15, 799 1681
00: 32: 13, 559 --> 00: 32: 18, 039
you have by James Brown we'd ideally 1682
00: 32: 15, 789 --> 00: 32: 18, 039 1683
00: 32: 15, 799 --> 00: 32: 20, 120 it to route to the to the question 1684
00: 32: 18, 029 --> 00: 32: 20, 120 1685
00: 32: 18, 039 --> 00: 32: 21, 440
answering subgraph from the intent 1686
00: 32: 20, 110 --> 00: 32: 21, 440 1687
00: 32: 20, 120 --> 00: 32: 23, 279
classifier 1688
00: 32: 21, 430 --> 00: 32: 23, 279 1689
00: 32: 21, 440 --> 00: 32: 26, 159
node and then within the question 1690
00: 32: 23, 269 --> 00: 32: 26, 159 1691
00: 32: 23, 279 --> 00: 32: 28, 799
answering subgraph we'd it to use 1692
00: 32: 26, 149 --> 00: 32: 28, 799 1693
00: 32: 26, 159 --> 00: 32: 30, 760
the lookup track tool before routing to 1694
00: 32: 28, 789 --> 00: 32: 30, 760 1695
00: 32: 28, 799 --> 00: 32: 32, 360
the compile follow-up node which just 1696
00: 32: 30, 750 --> 00: 32: 32, 360 1697
00: 32: 30, 760 --> 00: 32: 33, 639
cleans up the state and returns a nice 1698
00: 32: 32, 350 --> 00: 32: 33, 639 1699
00: 32: 32, 360 --> 00: 32: 36, 200
answer to the 1700
00: 32: 33, 629 --> 00: 32: 36, 200 1701
00: 32: 33, 639 --> 00: 32: 38, 519
user we're good to send this golden data 1702
00: 32: 36, 190 --> 00: 32: 38, 519 1703
00: 32: 36, 200 --> 00: 32: 41, 320
set to Langs Smith under the name chinuk 1704
00: 32: 38, 509 --> 00: 32: 41, 320 1705
00: 32: 38, 519 --> 00: 32: 44, 039
customer service boot 1706
00: 32: 41, 310 --> 00: 32: 44, 039 1707
00: 32: 41, 320 --> 00: 32: 45, 600
trajectory great so now that we have a 1708
00: 32: 44, 029 --> 00: 32: 45, 600 1709
00: 32: 44, 039 --> 00: 32: 47, 559
golden data set let's move on to step 1710
00: 32: 45, 590 --> 00: 32: 47, 559 1711
00: 32: 45, 600 --> 00: 32: 50, 159
two which is defining the application 1712
00: 32: 47, 549 --> 00: 32: 50, 159 1713
00: 32: 47, 559 --> 00: 32: 51, 960
logic that we want to evaluate to do so 1714
00: 32: 50, 149 --> 00: 32: 51, 960 1715
00: 32: 50, 159 --> 00: 32: 55, 480
we're going to need to create another 1716
00: 32: 51, 950 --> 00: 32: 55, 480 1717
00: 32: 51, 960 --> 00: 32: 58, 039
Target function called runor graph when 1718
00: 32: 55, 470 --> 00: 32: 58, 039 1719
00: 32: 55, 480 --> 00: 32: 59, 639
this evaluation is kicked off langi SD K 1720
00: 32: 58, 029 --> 00: 32: 59, 639 1721
00: 32: 58, 039 --> 00: 33: 1, 720
will automatically send the inputs from 1722
00: 32: 59, 629 --> 00: 33: 1, 720 1723
00: 32: 59, 639 --> 00: 33: 3, 720
our golden data set to this target 1724
00: 33: 1, 710 --> 00: 33: 3, 720 1725
00: 33: 1, 720 --> 00: 33: 6, 279
function which we're then going to pass 1726
00: 33: 3, 710 --> 00: 33: 6, 279 1727
00: 33: 3, 720 --> 00: 33: 7, 639
to our customer support agent which is 1728
00: 33: 6, 269 --> 00: 33: 7, 639 1729
00: 33: 6, 279 --> 00: 33: 10, 159
Den noted by 1730
00: 33: 7, 629 --> 00: 33: 10, 159 1731
00: 33: 7, 639 --> 00: 33: 11, 919
graph and what we're going to do is as 1732
00: 33: 10, 149 --> 00: 33: 11, 919 1733
00: 33: 10, 159 --> 00: 33: 13, 639
this customer support agent is answering 1734
00: 33: 11, 909 --> 00: 33: 13, 639 1735
00: 33: 11, 919 --> 00: 33: 17, 360
this question from the inputs varable 1736
00: 33: 13, 629 --> 00: 33: 17, 360 1737
00: 33: 13, 639 --> 00: 33: 18, 440
and data set is stream back the events 1738
00: 33: 17, 350 --> 00: 33: 18, 440 1739
00: 33: 17, 360 --> 00: 33: 20, 200
and we're even going to be able to 1740
00: 33: 18, 430 --> 00: 33: 20, 200 1741
00: 33: 18, 440 --> 00: 33: 22, 200
stream back the events from our 1742
00: 33: 20, 190 --> 00: 33: 22, 200 1743
00: 33: 20, 200 --> 00: 33: 24, 360
subgraphs because here we're setting 1744
00: 33: 22, 190 --> 00: 33: 24, 360 1745
00: 33: 22, 200 --> 00: 33: 25, 679
subgraphs equal to true in stream mode 1746
00: 33: 24, 350 --> 00: 33: 25, 679 1747
00: 33: 24, 360 --> 00: 33: 28, 000
equal to 1748
00: 33: 25, 669 --> 00: 33: 28, 000 1749
00: 33: 25, 679 --> 00: 33: 30, 600
bug and as these events are streaming 1750
00: 33: 27, 990 --> 00: 33: 30, 600 1751
00: 33: 28, 000 --> 00: 33: 34, 360
back we're going to do is append the 1752
00: 33: 30, 590 --> 00: 33: 34, 360 1753
00: 33: 30, 600 --> 00: 33: 37, 720
names of all the nodes and tools that we 1754
00: 33: 34, 350 --> 00: 33: 37, 720 1755
00: 33: 34, 360 --> 00: 33: 39, 159
utilize to an array called trajectory 1756
00: 33: 37, 710 --> 00: 33: 39, 159 1757
00: 33: 37, 720 --> 00: 33: 40, 960
and so at the very end when we return 1758
00: 33: 39, 149 --> 00: 33: 40, 960 1759
00: 33: 39, 159 --> 00: 33: 42, 399
this trajectory array we'll have the 1760
00: 33: 40, 950 --> 00: 33: 42, 399 1761
00: 33: 40, 960 --> 00: 33: 44, 519
names of all the nodes and the tools 1762
00: 33: 42, 389 --> 00: 33: 44, 519 1763
00: 33: 42, 399 --> 00: 33: 47, 760
that we routed to and used when 1764
00: 33: 44, 509 --> 00: 33: 47, 760 1765
00: 33: 44, 519 --> 00: 33: 47, 760
responding to that question from the 1766
00: 33: 47, 870 --> 00: aN: NaN, NaN 1767
00: 33: 47, 880 --> 00: 33: 51, 600
customer great so now we have our golden 1768
00: 33: 50, 110 --> 00: 33: 51, 600 1769
00: 33: 50, 120 --> 00: 33: 53, 840
data set in the application logic we 1770
00: 33: 51, 590 --> 00: 33: 53, 840 1771
00: 33: 51, 600 --> 00: 33: 56, 559
want to evaluate let's move on to step 1772
00: 33: 53, 830 --> 00: 33: 56, 559 1773
00: 33: 53, 840 --> 00: 33: 58, 480
three which is defining our evaluators 1774
00: 33: 56, 549 --> 00: 33: 58, 480 1775
00: 33: 56, 559 --> 00: 34: 0, 360
up until this point each of the two 1776
00: 33: 58, 470 --> 00: 34: 0, 360 1777
00: 33: 58, 480 --> 00: 34: 1, 399
evaluation strategies has just used a 1778
00: 34: 0, 350 --> 00: 34: 1, 399 1779
00: 34: 0, 360 --> 00: 34: 3, 880
single 1780
00: 34: 1, 389 --> 00: 34: 3, 880 1781
00: 34: 1, 399 --> 00: 34: 5, 360
evaluator in this trajectory evaluation 1782
00: 34: 3, 870 --> 00: 34: 5, 360 1783
00: 34: 3, 880 --> 00: 34: 7, 399
I'm going to use two 1784
00: 34: 5, 350 --> 00: 34: 7, 399 1785
00: 34: 5, 360 --> 00: 34: 10, 280
evaluators and the first evaluator is 1786
00: 34: 7, 389 --> 00: 34: 10, 280 1787
00: 34: 7, 399 --> 00: 34: 13, 879
called evaluate extra steps what it'll 1788
00: 34: 10, 270 --> 00: 34: 13, 879 1789
00: 34: 10, 280 --> 00: 34: 15, 320
do is it'll fetch the outputs or the 1790
00: 34: 13, 869 --> 00: 34: 15, 320 1791
00: 34: 13, 879 --> 00: 34: 17, 599
trory array that gets returned from my 1792
00: 34: 15, 310 --> 00: 34: 17, 599 1793
00: 34: 15, 320 --> 00: 34: 21, 040
target function and the reference 1794
00: 34: 17, 589 --> 00: 34: 21, 040 1795
00: 34: 17, 599 --> 00: 34: 22, 760
outputs from my golden data set both of 1796
00: 34: 21, 030 --> 00: 34: 22, 760 1797
00: 34: 21, 040 --> 00: 34: 24, 879
these are automatically passed to it by 1798
00: 34: 22, 750 --> 00: 34: 24, 879 1799
00: 34: 22, 760 --> 00: 34: 27, 919
Langs Smith's SDK when we kick off the 1800
00: 34: 24, 869 --> 00: 34: 27, 919 1801
00: 34: 24, 879 --> 00: 34: 29, 320
experiment and it'll just check if the 1802
00: 34: 27, 909 --> 00: 34: 29, 320 1803
00: 34: 27, 919 --> 00: 34: 32, 280
that my customer support agent took in 1804
00: 34: 29, 310 --> 00: 34: 32, 280 1805
00: 34: 29, 320 --> 00: 34: 34, 240
the Target function has additional steps 1806
00: 34: 32, 270 --> 00: 34: 34, 240 1807
00: 34: 32, 280 --> 00: 34: 36, 639
compared to the trajectory we defined in 1808
00: 34: 34, 230 --> 00: 34: 36, 639 1809
00: 34: 34, 240 --> 00: 34: 40, 359
our reference output and if it did take 1810
00: 34: 36, 629 --> 00: 34: 40, 359 1811
00: 34: 36, 639 --> 00: 34: 41, 879
some extra steps we'll return it here 1812
00: 34: 40, 349 --> 00: 34: 41, 879 1813
00: 34: 40, 359 --> 00: 34: 43, 399
and the reason we're checking for extra 1814
00: 34: 41, 869 --> 00: 34: 43, 399 1815
00: 34: 41, 879 --> 00: 34: 45, 320
steps is if you remember from earlier 1816
00: 34: 43, 389 --> 00: 34: 45, 320 1817
00: 34: 43, 399 --> 00: 34: 46, 760
this video we want to make sure our 1818
00: 34: 45, 310 --> 00: 34: 46, 760 1819
00: 34: 45, 320 --> 00: 34: 48, 919
customer support agent doesn't take an 1820
00: 34: 46, 750 --> 00: 34: 48, 919 1821
00: 34: 46, 760 --> 00: 34: 51, 240
inefficient trajectory so we want to 1822
00: 34: 48, 909 --> 00: 34: 51, 240 1823
00: 34: 48, 919 --> 00: 34: 53, 480
make sure for example when we get routed 1824
00: 34: 51, 230 --> 00: 34: 53, 480 1825
00: 34: 51, 240 --> 00: 34: 55, 720
to the question answering subgraph we 1826
00: 34: 53, 470 --> 00: 34: 55, 720 1827
00: 34: 53, 480 --> 00: 34: 57, 839
don't call one tool an unnecessary 1828
00: 34: 55, 710 --> 00: 34: 57, 839 1829
00: 34: 55, 720 --> 00: 34: 59, 599
unnecessary number of times and we don't 1830
00: 34: 57, 829 --> 00: 34: 59, 599 1831
00: 34: 57, 839 --> 00: 35: 2, 400
call a wrong 1832
00: 34: 59, 589 --> 00: 35: 2, 400 1833
00: 34: 59, 599 --> 00: 35: 4, 880
tool our second evaluator is going to be 1834
00: 35: 2, 390 --> 00: 35: 4, 880 1835
00: 35: 2, 400 --> 00: 35: 6, 839
called evalate unmatch steps it's also 1836
00: 35: 4, 870 --> 00: 35: 6, 839 1837
00: 35: 4, 880 --> 00: 35: 8, 599
going to automatically receive the 1838
00: 35: 6, 829 --> 00: 35: 8, 599 1839
00: 35: 6, 839 --> 00: 35: 11, 240
outputs or the trajectory arrays that 1840
00: 35: 8, 589 --> 00: 35: 11, 240 1841
00: 35: 8, 599 --> 00: 35: 13, 800
were returned by my target function and 1842
00: 35: 11, 230 --> 00: 35: 13, 800 1843
00: 35: 11, 240 --> 00: 35: 16, 320
the reference outputs for my golden data 1844
00: 35: 13, 790 --> 00: 35: 16, 320 1845
00: 35: 13, 800 --> 00: 35: 17, 920
set and this eval on my steps function 1846
00: 35: 16, 310 --> 00: 35: 17, 920 1847
00: 35: 16, 320 --> 00: 35: 20, 680
is going to check if our customer 1848
00: 35: 17, 910 --> 00: 35: 20, 680 1849
00: 35: 17, 920 --> 00: 35: 22, 480
support agent called some tools or took 1850
00: 35: 20, 670 --> 00: 35: 22, 480 1851
00: 35: 20, 680 --> 00: 35: 24, 680
some steps that are not in the directory 1852
00: 35: 22, 470 --> 00: 35: 24, 680 1853
00: 35: 22, 480 --> 00: 35: 25, 880
we defined in our reference output and 1854
00: 35: 24, 670 --> 00: 35: 25, 880 1855
00: 35: 24, 680 --> 00: 35: 28, 240
this check is going to be order 1856
00: 35: 25, 870 --> 00: 35: 28, 240 1857
00: 35: 25, 880 --> 00: 35: 30, 119
sensitive so if our customer sport agent 1858
00: 35: 28, 230 --> 00: 35: 30, 119 1859
00: 35: 28, 240 --> 00: 35: 32, 880
followed the trajectory step one step 1860
00: 35: 30, 109 --> 00: 35: 32, 880 1861
00: 35: 30, 119 --> 00: 35: 34, 760
two step three but the ideal trajectory 1862
00: 35: 32, 870 --> 00: 35: 34, 760 1863
00: 35: 32, 880 --> 00: 35: 37, 800
that we defined in our golden data set 1864
00: 35: 34, 750 --> 00: 35: 37, 800 1865
00: 35: 34, 760 --> 00: 35: 39, 160
is step three step two step one we're 1866
00: 35: 37, 790 --> 00: 35: 39, 160 1867
00: 35: 37, 800 --> 00: 35: 42, 200 going to say that our customer 1868
00: 35: 39, 150 --> 00: 35: 42, 200 1869
00: 35: 39, 160 --> 00: 35: 43, 480
support agent had unmatched steps 1870
00: 35: 42, 190 --> 00: 35: 43, 480 1871
00: 35: 42, 200 --> 00: 35: 46, 200
because even though the names of the 1872
00: 35: 43, 470 --> 00: 35: 46, 200 1873
00: 35: 43, 480 --> 00: 35: 49, 359
steps are correct and match the ones in 1874
00: 35: 46, 190 --> 00: 35: 49, 359 1875
00: 35: 46, 200 --> 00: 35: 51, 119
our reference output the order is 1876
00: 35: 49, 349 --> 00: 35: 51, 119 1877
00: 35: 49, 359 --> 00: 35: 52, 520
incorrect and so we're just going to 1878
00: 35: 51, 109 --> 00: 35: 52, 520 1879
00: 35: 51, 119 --> 00: 35: 55, 560
return the number of unmatched steps 1880
00: 35: 52, 510 --> 00: 35: 55, 560 1881
00: 35: 52, 520 --> 00: 35: 57, 720
here under the key unmatched steps and 1882
00: 35: 55, 550 --> 00: 35: 57, 720 1883
00: 35: 55, 560 --> 00: 35: 59, 920
we're returning the extra steps under 1884
00: 35: 57, 710 --> 00: 35: 59, 920 1885
00: 35: 57, 720 --> 00: 36: 1, 599
the key extra steps and you'll see both 1886
00: 35: 59, 910 --> 00: 36: 1, 599 1887
00: 35: 59, 920 --> 00: 36: 3, 160
these keys and their Associated 1888
00: 36: 1, 589 --> 00: 36: 3, 160 1889
00: 36: 1, 599 --> 00: 36: 5, 400
value in length bit 1890
00: 36: 3, 150 --> 00: 36: 5, 400 1891
00: 36: 3, 160 --> 00: 36: 7, 920
CI our last step is to run the 1892
00: 36: 5, 390 --> 00: 36: 7, 920 1893
00: 36: 5, 400 --> 00: 36: 9, 319
evaluation using the evaluate function 1894
00: 36: 7, 910 --> 00: 36: 9, 319 1895
00: 36: 7, 920 --> 00: 36: 11, 040
we're going to specify the target 1896
00: 36: 9, 309 --> 00: 36: 11, 040 1897
00: 36: 9, 319 --> 00: 36: 13, 040
function here the name of the golden 1898
00: 36: 11, 030 --> 00: 36: 13, 040 1899
00: 36: 11, 040 --> 00: 36: 14, 920
data set the list of evaluators that 1900
00: 36: 13, 030 --> 00: 36: 14, 920 1901
00: 36: 13, 040 --> 00: 36: 16, 520
we're using and the name of the 1902
00: 36: 14, 910 --> 00: 36: 16, 520 1903
00: 36: 14, 920 --> 00: 36: 18, 359
experiment which will show up on 1904
00: 36: 16, 510 --> 00: 36: 18, 359 1905
00: 36: 16, 520 --> 00: 36: 20, 319
lenss withth UI and we're going to hop 1906
00: 36: 18, 349 --> 00: 36: 20, 319 1907
00: 36: 18, 359 --> 00: 36: 22, 200
there now all we're in the lenss 1908
00: 36: 20, 309 --> 00: 36: 22, 200 1909
00: 36: 20, 319 --> 00: 36: 24, 160
withth UI the first thing to note is 1910
00: 36: 22, 190 --> 00: 36: 24, 160 1911
00: 36: 22, 200 --> 00: 36: 27, 359
that we successfully created our gold to 1912
00: 36: 24, 150 --> 00: 36: 27, 359 1913
00: 36: 24, 160 --> 00: 36: 29, 640
data set so here I'm in our data set Chu 1914
00: 36: 27, 349 --> 00: 36: 29, 640 1915
00: 36: 27, 359 --> 00: 36: 31, 000
C for Server spot directory and we can 1916
00: 36: 29, 630 --> 00: 36: 31, 000 1917
00: 36: 29, 640 --> 00: 36: 33, 160
see that the inputs and the outputs that 1918
00: 36: 30, 990 --> 00: 36: 33, 160 1919
00: 36: 31, 000 --> 00: 36: 35, 880
we defined in our code were successfully 1920
00: 36: 33, 150 --> 00: 36: 35, 880 1921
00: 36: 33, 160 --> 00: 36: 37, 839
sent over to lsmith so I'll click into 1922
00: 36: 35, 870 --> 00: 36: 37, 839 1923
00: 36: 35, 880 --> 00: 36: 40, 319
this example input output pair from our 1924
00: 36: 37, 829 --> 00: 36: 40, 319 1925
00: 36: 37, 839 --> 00: 36: 41, 800
golden data set we can see the input is 1926
00: 36: 40, 309 --> 00: 36: 41, 800 1927
00: 36: 40, 319 --> 00: 36: 44, 319
just that question we had to finded in 1928
00: 36: 41, 790 --> 00: 36: 44, 319 1929
00: 36: 41, 800 --> 00: 36: 45, 800
code the question is my name is Aaron 1930
00: 36: 44, 309 --> 00: 36: 45, 800 1931
00: 36: 44, 319 --> 00: 36: 48, 240
Mitchell and i' a refund on my lead 1932
00: 36: 45, 790 --> 00: 36: 48, 240 1933
00: 36: 45, 800 --> 00: 36: 50, 040
Zeppelin purchases Aaron also provides 1934
00: 36: 48, 230 --> 00: 36: 50, 040 1935
00: 36: 48, 240 --> 00: 36: 52, 560
his phone number so we can identify him 1936
00: 36: 50, 030 --> 00: 36: 52, 560 1937
00: 36: 50, 040 --> 00: 36: 55, 079
in the database and we can see in the 1938
00: 36: 52, 550 --> 00: 36: 55, 079 1939
00: 36: 52, 560 --> 00: 36: 56, 680
reference output the ideal trory that we 1940
00: 36: 55, 069 --> 00: 36: 56, 680 1941
00: 36: 55, 079 --> 00: 36: 59, 200
defined in code was also sent over 1942
00: 36: 56, 670 --> 00: 36: 59, 200 1943
00: 36: 56, 680 --> 00: 37: 0, 480
successfully so the ideal directory we'd 1944
00: 36: 59, 190 --> 00: 37: 0, 480 1945
00: 36: 59, 200 --> 00: 37: 2, 440
want our agent to follow when it 1946
00: 37: 0, 470 --> 00: 37: 2, 440 1947
00: 37: 0, 480 --> 00: 37: 5, 079
receives a query this is to first 1948
00: 37: 2, 430 --> 00: 37: 5, 079 1949
00: 37: 2, 440 --> 00: 37: 7, 599
get routed to the refund subgraph then 1950
00: 37: 5, 069 --> 00: 37: 7, 599 1951
00: 37: 5, 079 --> 00: 37: 10, 240
get routed to The Gather info node then 1952
00: 37: 7, 589 --> 00: 37: 10, 240 1953
00: 37: 7, 599 --> 00: 37: 12, 040
get routed to the lookup node and 1954
00: 37: 10, 230 --> 00: 37: 12, 040 1955
00: 37: 10, 240 --> 00: 37: 15, 000
then ultimately that last compile 1956
00: 37: 12, 030 --> 00: 37: 15, 000 1957
00: 37: 12, 040 --> 00: 37: 17, 280
followup node great so our golden data 1958
00: 37: 14, 990 --> 00: 37: 17, 280 1959
00: 37: 15, 000 --> 00: 37: 19, 520
set looks good and it got 1960
00: 37: 17, 270 --> 00: 37: 19, 520 1961
00: 37: 17, 280 --> 00: 37: 21, 240
successfully sent over to lsmith Let's 1962
00: 37: 19, 510 --> 00: 37: 21, 240 1963
00: 37: 19, 520 --> 00: 37: 23, 920
click in and look at our experiment in a 1964
00: 37: 21, 230 --> 00: 37: 23, 920 1965
00: 37: 21, 240 --> 00: 37: 25, 800
bit deeper detail so in this view as 1966
00: 37: 23, 910 --> 00: 37: 25, 800 1967
00: 37: 23, 920 --> 00: 37: 28, 079
usual we can see the inputs in the 1968
00: 37: 25, 790 --> 00: 37: 28, 079 1969
00: 37: 25, 800 --> 00: 37: 29, 480
outputs from our golden data set 1970
00: 37: 28, 069 --> 00: 37: 29, 480 1971
00: 37: 28, 079 --> 00: 37: 31, 440
and then we can see the trajectory that 1972
00: 37: 29, 470 --> 00: 37: 31, 440 1973
00: 37: 29, 480 --> 00: 37: 32, 920
our customer support agent followed when 1974
00: 37: 31, 430 --> 00: 37: 32, 920 1975
00: 37: 31, 440 --> 00: 37: 35, 640
it was given the input from the golden 1976
00: 37: 32, 910 --> 00: 37: 35, 640 1977
00: 37: 32, 920 --> 00: 37: 36, 880
data set in that Target function and so 1978
00: 37: 35, 630 --> 00: 37: 36, 880 1979
00: 37: 35, 640 --> 00: 37: 38, 720
we can see for this input from the 1980
00: 37: 36, 870 --> 00: 37: 38, 720 1981
00: 37: 36, 880 --> 00: 37: 40, 280
golden data set our customer support 1982
00: 37: 38, 710 --> 00: 37: 40, 280 1983
00: 37: 38, 720 --> 00: 37: 42, 359
agent followed this trajectory when 1984
00: 37: 40, 270 --> 00: 37: 42, 359 1985
00: 37: 40, 280 --> 00: 37: 44, 400
constructing its final 1986
00: 37: 42, 349 --> 00: 37: 44, 400 1987
00: 37: 42, 359 --> 00: 37: 46, 040
answer and then we can see the two 1988
00: 37: 44, 390 --> 00: 37: 46, 040 1989
00: 37: 44, 400 --> 00: 37: 48, 640
evaluators that were attached to this 1990
00: 37: 46, 030 --> 00: 37: 48, 640 1991
00: 37: 46, 040 --> 00: 37: 50, 480
new output by the extra steps evaluator 1992
00: 37: 48, 630 --> 00: 37: 50, 480 1993
00: 37: 48, 640 --> 00: 37: 52, 839
function and the unmatched steps 1994
00: 37: 50, 470 --> 00: 37: 52, 839 1995
00: 37: 50, 480 --> 00: 37: 54, 520
evaluator function so for this input 1996
00: 37: 52, 829 --> 00: 37: 54, 520 1997
00: 37: 52, 839 --> 00: 37: 56, 760
from the golden data set or this 1998
00: 37: 54, 510 --> 00: 37: 56, 760 1999
00: 37: 54, 520 --> 00: 37: 58, 920
question our customer support agent did 2000
00: 37: 56, 750 --> 00: 37: 58, 920 2001
00: 37: 56, 760 --> 00: 38: 1, 079
phenomenal you can see that it didn't 2002
00: 37: 58, 910 --> 00: 38: 1, 079 2003
00: 37: 58, 920 --> 00: 38: 3, 480
take any extra steps and it didn't have 2004
00: 38: 1, 069 --> 00: 38: 3, 480 2005
00: 38: 1, 079 --> 00: 38: 5, 599
any unmatched steps in fact the 2006
00: 38: 3, 470 --> 00: 38: 5, 599 2007
00: 38: 3, 480 --> 00: 38: 8, 400
trajectory that it followed is an exact 2008
00: 38: 5, 589 --> 00: 38: 8, 400 2009
00: 38: 5, 599 --> 00: 38: 10, 400
one: one or perfect match with the 2010
00: 38: 8, 390 --> 00: 38: 10, 400 2011
00: 38: 8, 400 --> 00: 38: 11, 560
trajectory that we defined in our 2012
00: 38: 10, 390 --> 00: 38: 11, 560 2013
00: 38: 10, 400 --> 00: 38: 14, 880
reference 2014
00: 38: 11, 550 --> 00: 38: 14, 880 2015
00: 38: 11, 560 --> 00: 38: 16, 960
output great and our agent did perfect 2016
00: 38: 14, 870 --> 00: 38: 16, 960 2017
00: 38: 14, 880 --> 00: 38: 19, 240
on these other three inputs as well from 2018
00: 38: 16, 950 --> 00: 38: 19, 240 2019
00: 38: 16, 960 --> 00: 38: 22, 720
our golden data set so here no extra 2020
00: 38: 19, 230 --> 00: 38: 22, 720 2021
00: 38: 19, 240 --> 00: 38: 24, 319
steps no unmatched steps one input where 2022
00: 38: 22, 710 --> 00: 38: 24, 319 2023
00: 38: 22, 720 --> 00: 38: 26, 480
our customer support agent struggled a 2024
00: 38: 24, 309 --> 00: 38: 26, 480 2025
00: 38: 24, 319 --> 00: 38: 28, 599
little bit is this input where the 2026
00: 38: 26, 470 --> 00: 38: 28, 599 2027
00: 38: 26, 480 --> 00: 38: 30, 440
customer asked who recorded wish you 2028
00: 38: 28, 589 --> 00: 38: 30, 440 2029
00: 38: 28, 599 --> 00: 38: 32, 520
were here again what other albums by 2030
00: 38: 30, 430 --> 00: 38: 32, 520 2031
00: 38: 30, 440 --> 00: 38: 35, 119
them do you have so when our customer 2032
00: 38: 32, 510 --> 00: 38: 35, 119 2033
00: 38: 32, 520 --> 00: 38: 38, 000
support agent was given this question it 2034
00: 38: 35, 109 --> 00: 38: 38, 000 2035
00: 38: 35, 119 --> 00: 38: 40, 200
not only took some extra steps it 2036
00: 38: 37, 990 --> 00: 38: 40, 200 2037
00: 38: 38, 000 --> 00: 38: 42, 319 took some unnotched steps and 2038
00: 38: 40, 190 --> 00: 38: 42, 319 2039
00: 38: 40, 200 --> 00: 38: 44, 160
let's look at what took place so 2040
00: 38: 42, 309 --> 00: 38: 44, 160 2041
00: 38: 42, 319 --> 00: 38: 46, 440
ideally when our customer support agent 2042
00: 38: 44, 150 --> 00: 38: 46, 440 2043
00: 38: 44, 160 --> 00: 38: 47, 960
receives a query this we would 2044
00: 38: 46, 430 --> 00: 38: 47, 960 2045
00: 38: 46, 440 --> 00: 38: 49, 680
to Route it to the question answering 2046
00: 38: 47, 950 --> 00: 38: 49, 680 2047
00: 38: 47, 960 --> 00: 38: 51, 079
subgraph because this question is about 2048
00: 38: 49, 670 --> 00: 38: 51, 079 2049
00: 38: 49, 680 --> 00: 38: 53, 760
the products and offerings of the music 2050
00: 38: 51, 069 --> 00: 38: 53, 760 2051
00: 38: 51, 079 --> 00: 38: 56, 480
store we'd it to First Call the 2052
00: 38: 53, 750 --> 00: 38: 56, 480 2053
00: 38: 53, 760 --> 00: 38: 58, 400
lookup track tool so in this case it 2054
00: 38: 56, 470 --> 00: 38: 58, 400 2055
00: 38: 56, 480 --> 00: 38: 59, 680
look up the information on the track 2056
00: 38: 58, 390 --> 00: 38: 59, 680 2057
00: 38: 58, 400 --> 00: 39: 2, 079
wish you were here 2058
00: 38: 59, 670 --> 00: 39: 2, 079 2059
00: 38: 59, 680 --> 00: 39: 3, 560
again and then to answer this second 2060
00: 39: 2, 069 --> 00: 39: 3, 560 2061
00: 39: 2, 079 --> 00: 39: 5, 680
part of the question what other albums 2062
00: 39: 3, 550 --> 00: 39: 5, 680 2063
00: 39: 3, 560 --> 00: 39: 7, 839
by them do you have we'd want our agent 2064
00: 39: 5, 670 --> 00: 39: 7, 839 2065
00: 39: 5, 680 --> 00: 39: 9, 319
to then use the lookup album tool so 2066
00: 39: 7, 829 --> 00: 39: 9, 319 2067
00: 39: 7, 839 --> 00: 39: 12, 560
take the information it got from the 2068
00: 39: 9, 309 --> 00: 39: 12, 560 2069
00: 39: 9, 319 --> 00: 39: 15, 520
lookup track tool look up all the albums 2070
00: 39: 12, 550 --> 00: 39: 15, 520 2071
00: 39: 12, 560 --> 00: 39: 17, 800
Associated with the artist who 2072
00: 39: 15, 510 --> 00: 39: 17, 800 2073
00: 39: 15, 520 --> 00: 39: 20, 800
created wish you were here again and 2074
00: 39: 17, 790 --> 00: 39: 20, 800 2075
00: 39: 17, 800 --> 00: 39: 23, 319
then return it to the user our agent 2076
00: 39: 20, 790 --> 00: 39: 23, 319 2077
00: 39: 20, 800 --> 00: 39: 25, 319
didn't follow this optimal trajectory it 2078
00: 39: 23, 309 --> 00: 39: 25, 319 2079
00: 39: 23, 319 --> 00: 39: 27, 760
got tripped up and instead first called 2080
00: 39: 25, 309 --> 00: 39: 27, 760 2081
00: 39: 25, 319 --> 00: 39: 30, 119
the lookup album tool when should have 2082
00: 39: 27, 750 --> 00: 39: 30, 119 2083
00: 39: 27, 760 --> 00: 39: 31, 880
first called the lookup track tool and 2084
00: 39: 30, 109 --> 00: 39: 31, 880 2085
00: 39: 30, 119 --> 00: 39: 34, 119
as a result it realized it needed to 2086
00: 39: 31, 870 --> 00: 39: 34, 119 2087
00: 39: 31, 880 --> 00: 39: 36, 040
course correct and it needed to First 2088
00: 39: 34, 109 --> 00: 39: 36, 040 2089
00: 39: 34, 119 --> 00: 39: 38, 800
Call the lookup track tool to get the 2090
00: 39: 36, 030 --> 00: 39: 38, 800 2091
00: 39: 36, 040 --> 00: 39: 41, 040
information on who recorded this song 2092
00: 39: 38, 790 --> 00: 39: 41, 040 2093
00: 39: 38, 800 --> 00: 39: 42, 160
and then call the lookup album tool and 2094
00: 39: 41, 030 --> 00: 39: 42, 160 2095
00: 39: 41, 040 --> 00: 39: 44, 160
be able to answer that second part of 2096
00: 39: 42, 150 --> 00: 39: 44, 160 2097
00: 39: 42, 160 --> 00: 39: 46, 400
the query which is what other albums by 2098
00: 39: 44, 150 --> 00: 39: 46, 400 2099
00: 39: 44, 160 --> 00: 39: 48, 720
that artist do you have and so as a 2100
00: 39: 46, 390 --> 00: 39: 48, 720 2101
00: 39: 46, 400 --> 00: 39: 50, 839
result it had it took three extra steps 2102
00: 39: 48, 710 --> 00: 39: 50, 839 2103
00: 39: 48, 720 --> 00: 39: 53, 720
and had three unmatched 2104
00: 39: 50, 829 --> 00: 39: 53, 720 2105
00: 39: 50, 839 --> 00: 39: 55, 079
steps great but other than that 2106
00: 39: 53, 710 --> 00: 39: 55, 079 2107
00: 39: 53, 720 --> 00: 39: 56, 880
the agent performed pretty well on this 2108
00: 39: 55, 069 --> 00: 39: 56, 880 2109
00: 39: 55, 079 --> 00: 39: 58, 319
directory evaluation we'll just have to 2110
00: 39: 56, 870 --> 00: 39: 58, 319 2111
00: 39: 56, 880 --> 00: 40: 0, 599
make sure going forward we keep an eye 2112
00: 39: 58, 309 --> 00: 40: 0, 599 2113
00: 39: 58, 319 --> 00: 40: 2, 440
on inputs this and tweak some part 2114
00: 40: 0, 589 --> 00: 40: 2, 440 2115
00: 40: 0, 599 --> 00: 40: 5, 160
of our agent so it does better going 2116
00: 40: 2, 430 --> 00: 40: 5, 160 2117
00: 40: 2, 440 --> 00: 40: 6, 599
forward awesome so those are the three 2118
00: 40: 5, 150 --> 00: 40: 6, 599 2119
00: 40: 5, 160 --> 00: 40: 8, 480
valuation strategies I wanted to show 2120
00: 40: 6, 589 --> 00: 40: 8, 480 2121
00: 40: 6, 599 --> 00: 40: 10, 440
off in this video and this will be the 2122
00: 40: 8, 470 --> 00: 40: 10, 440 2123
00: 40: 8, 480 --> 00: 40: 12, 720
end of the video if you want to keep 2124
00: 40: 10, 430 --> 00: 40: 12, 720 2125
00: 40: 10, 440 --> 00: 40: 15, 839
learning about building agents or 2126
00: 40: 12, 710 --> 00: 40: 15, 839 2127
00: 40: 12, 720 --> 00: 40: 18, 119
evaluating agents or anything beyond 2128
00: 40: 15, 829 --> 00: 40: 18, 119 2129
00: 40: 15, 839 --> 00: 40: 19, 960
I'd really encourage you to take the 2130
00: 40: 18, 109 --> 00: 40: 19, 960 2131
00: 40: 18, 119 --> 00: 40: 22, 200
introduction to lsmith course we've put 2132
00: 40: 19, 950 --> 00: 40: 22, 200 2133
00: 40: 19, 960 --> 00: 40: 24, 440
together and the introduction to L graph 2134
00: 40: 22, 190 --> 00: 40: 24, 440 2135
00: 40: 22, 200 --> 00: 40: 27, 640
course put together you can access both 2136
00: 40: 24, 430 --> 00: 40: 27, 640 2137
00: 40: 24, 440 --> 00: 40: 29, 520
at the URL academy. Len chain. com 2138
00: 40: 27, 630 --> 00: 40: 29, 520 2139
00: 40: 27, 640 --> 00: 40: 31, 119
collections this will give you a deep 2140
00: 40: 29, 510 --> 00: 40: 31, 119 2141
00: 40: 29, 520 --> 00: 40: 33, 160
dive into lsmith we've touched a little 2142
00: 40: 31, 109 --> 00: 40: 33, 160 2143
00: 40: 31, 119 --> 00: 40: 35, 800
bit on it in this video just from the 2144
00: 40: 33, 150 --> 00: 40: 35, 800 2145
00: 40: 33, 160 --> 00: 40: 37, 520
standpoint of experiments and data setes 2146
00: 40: 35, 790 --> 00: 40: 37, 520 2147
00: 40: 35, 800 --> 00: 40: 39, 240
and this will be a deep dive into Lang 2148
00: 40: 37, 510 --> 00: 40: 39, 240 2149
00: 40: 37, 520 --> 00: 40: 41, 760
graph our open source framework which 2150
00: 40: 39, 230 --> 00: 40: 41, 760 2151
00: 40: 39, 240 --> 00: 40: 43, 119
helps you build a gentic applications so 2152
00: 40: 41, 750 --> 00: 40: 43, 119 2153
00: 40: 41, 760 --> 00: 40: 46, 560
I hope this is helpful and I'll see 2154
00: 40: 43, 109 --> 00: 40: 46, 560 2155
00: 40: 43, 119 --> 00: 40: 46, 560
you in the next one